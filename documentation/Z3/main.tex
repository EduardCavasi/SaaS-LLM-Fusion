\documentclass[12pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[section]{placeins}  
\usepackage{listings}
\usepackage{float}  
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{float}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{appendix}
\usepackage{parskip}
\setlength{\parskip}{1em}
\onehalfspacing

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
    pdfborder={0 0 0},
    pdftitle={Verified Meeting Scheduler - Z3 SMT Solver Integration},
    pdfauthor={Raluca-Mihaela Adam}
}

\geometry{margin=1.5cm, top=2.5cm, bottom=2.5cm}

\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    captionpos=b,
    % ADD THESE LINES:
    xleftmargin=20pt,           % Left margin for better wrapping
    xrightmargin=20pt,          % Right margin
    framesep=10pt,              % Space between frame and code
    framexleftmargin=20pt,      % Frame left margin
    framexrightmargin=20pt,     % Frame right margin
    framextopmargin=10pt,       % Frame top margin
    framexbottommargin=10pt,    % Frame bottom margin
    % Allow page breaks in listings:
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookrightarrow\space}},
    prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    % Better line breaking:
    breakindent=20pt,
    breakautoindent=true
}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    {\Huge\bfseries Verified Meeting Scheduler\par}
    \vspace{0.5cm}
    {\Large\bfseries Z3 SMT Solver Integration for Theorem Proving\par}
    \vspace{2cm}
    {\Large\bfseries Raluca-Mihaela Adam\par}
    \vfill
    {\large Technical University of Cluj-Napoca\\Computer Science Department\\3rd Year, Group 30432\par}
    \vspace{1cm}
    {\large \today\par}
\end{titlepage}

\newpage

\begin{abstract}
\addcontentsline{toc}{section}{Abstract}
This report documents a \emph{Verified Meeting Scheduler} project that implements a dual-layer verification approach combining static formal methods with dynamic runtime monitoring. The complete system is a full-stack web application comprising a Spring Boot 3.5.7 backend and Next.js 16 frontend, designed to ensure scheduling correctness through multiple verification techniques.

The project integrates two complementary verification methodologies: (1) Runtime Verification using monitor specifications to enforce temporal properties during system execution dynamically, and (2) static constraint verification using Microsoft's Z3 SMT (Satisfiability Modulo Theories) solver to validate scheduling feasibility before state changes occur. This layered approach prevents constraint violations both at design time (via Z3) and during runtime (via monitoring).

\emph{This document specifically focuses on the Z3 SMT solver integration component} for static constraint verification. The implementation encodes scheduling constraints—including room overlap prevention, participant availability checks, and capacity limitations—as SMT formulas using integer arithmetic theory. The Z3 solver (version 4.13.0) performs pre-execution verification, ensuring all constraints are satisfied before any database writes occur, thus preventing invalid states from entering the system.

The backend architecture utilizes Spring Data JPA for persistence with H2 database for development, Spring Web for RESTful services, and Lombok for code generation. The Z3 integration demonstrates practical patterns for incorporating automated theorem proving into Spring Boot applications through dependency injection and proper lifecycle management.

The successful implementation shows that automated theorem proving can complement runtime verification techniques, creating a more robust verification strategy than either approach alone. This integration represents a significant step toward making formal methods accessible and practical for mainstream software engineering projects.
\end{abstract}

\newpage

\section*{Team Members}
\addcontentsline{toc}{section}{Team Members}
\begin{itemize}
    \item \textbf{Raluca-Mihaela Adam} - Z3 SMT Solver Implementation
    \item \textbf{Eduard-Paul Cavasi} - Runtime Verification Implementation
\end{itemize}

\newpage

\tableofcontents

\newpage

\section{Final Project: Design}
\label{sec:design}

\subsection{Design Models}

\subsubsection{Project Overview}
\label{subsec:overview}

\subsubsection*{System Description}
The Verified Meeting Scheduler is a full-stack web application designed to manage meeting scheduling with formal verification guarantees. The system ensures correctness through a dual-layer verification approach combining static constraint solving (Z3 SMT Solver) and dynamic runtime monitoring.

The application provides a RESTful API backend built with Spring Boot 3.5.7 and a modern web frontend built with Next.js 16. Users can create, update, confirm, reject, and delete meetings while the system automatically verifies that all scheduling constraints are satisfied and temporal properties are maintained.

The Z3 SMT Solver component performs \emph{pre-execution} constraint verification, checking scheduling feasibility before any database writes occur. This prevents invalid states from entering the system, complementing the runtime verification layer that monitors temporal properties during execution.

\subsubsection*{System Architecture}
The system follows a three-tier architecture:

\begin{itemize}
    \item \textbf{Presentation Layer}: Next.js 16 frontend with TypeScript, providing a responsive user interface with real-time verification feedback
    \item \textbf{Business Logic Layer}: Spring Boot REST API with service-oriented architecture, integrating Z3 solver and Runtime Verification Monitor
    \item \textbf{Data Layer}: H2 in-memory database (development) with JPA/Hibernate ORM, supporting PostgreSQL for production
\end{itemize}

The verification components are integrated at the business logic layer:
\begin{itemize}
    \item \textbf{Z3 SMT Solver}: Performs pre-execution constraint checking before database writes
    \item \textbf{Runtime Verification Monitor}: Monitors post-execution system state and temporal properties
\end{itemize}

The Z3 solver is integrated as a Spring \texttt{@Component}, initialized at application startup using \texttt{@PostConstruct} and properly cleaned up using \texttt{@PreDestroy}. Each constraint check creates a new Solver instance for thread safety.

\subsubsection*{Technology Stack}
\subsubsection*{Backend Technologies:}
\begin{itemize}
    \item \textbf{Spring Boot 3.5.7}: Core framework providing dependency injection, auto-configuration, and embedded server
    \item \textbf{Spring Data JPA}: Data access abstraction layer for database operations
    \item \textbf{Spring Web}: RESTful web services and MVC framework
    \item \textbf{Spring AOP}: Aspect-Oriented Programming for cross-cutting concerns
    \item \textbf{Hibernate/JPA}: Object-Relational Mapping for database persistence
    \item \textbf{H2 Database}: Lightweight in-memory database for development and testing
    \item \textbf{Lombok}: Code generation library to reduce boilerplate
    \item \textbf{Maven}: Build automation and dependency management
    \item \textbf{Java 17}: Programming language with modern features
\end{itemize}

\subsubsection*{Frontend Technologies:}
\begin{itemize}
    \item \textbf{Next.js 16}: React framework with server-side rendering
    \item \textbf{TypeScript}: Type-safe JavaScript for better code quality
    \item \textbf{Tailwind CSS}: Utility-first CSS framework for styling
    \item \textbf{React Hooks}: Modern React state management
\end{itemize}

\subsubsection*{Verification Technologies:}
\begin{itemize}
    \item \textbf{Z3 SMT Solver 4.13.0}: Microsoft's automated theorem prover for static constraint verification
    \item \textbf{Custom Runtime Verification Monitor}: Runtime verification using Spring AOP for non-invasive monitoring of temporal properties
    \item \textbf{Spring AOP}: For non-invasive instrumentation of service methods
\end{itemize}

\subsubsection{Theoretical Background}
\label{subsec:theory}

\subsubsection*{Satisfiability Modulo Theories (SMT)}
Satisfiability Modulo Theories (SMT) extends Boolean satisfiability (SAT) by incorporating theories from various domains (integers, reals, arrays, uninterpreted functions, etc.). An SMT solver determines whether a logical formula is satisfiable under these theories.

Unlike pure SAT solvers that work with Boolean variables, SMT solvers can reason about:
\begin{itemize}
    \item \textbf{Integer Arithmetic}: Linear and non-linear integer constraints
    \item \textbf{Real Arithmetic}: Real number constraints
    \item \textbf{Arrays}: Array read/write operations
    \item \textbf{Bit-vectors}: Fixed-size bit manipulation
    \item \textbf{Uninterpreted Functions}: Functions without specific semantics
\end{itemize}

\subsubsection*{Z3 Theorem Prover}
Z3 is a high-performance SMT solver developed by Microsoft Research. It is one of the most widely used SMT solvers in both academia and industry. Key features include:

\begin{itemize}
    \item \textbf{Multiple Theories}: Supports linear arithmetic, bit-vectors, arrays, uninterpreted functions, and more
    \item \textbf{Efficient Algorithms}: Implements DPLL(T) with theory-specific decision procedures
    \item \textbf{Model Generation}: Produces satisfying assignments when formulas are satisfiable
    \item \textbf{Unsat Cores}: Identifies minimal unsatisfiable subsets when formulas are unsatisfiable
    \item \textbf{Java API}: Provides a Java API for integration with Java applications
    \item \textbf{Platform Support}: Available on Windows, Linux, and macOS via z3-turnkey package
\end{itemize}

Z3 uses a combination of:
\begin{itemize}
    \item \textbf{CDCL (Conflict-Driven Clause Learning)}: For Boolean satisfiability
    \item \textbf{Theory-Specific Procedures}: For each supported theory
    \item \textbf{Lazy Theory Combination}: Combines multiple theories efficiently
\end{itemize}

\subsubsection*{Constraint Encoding}
Scheduling constraints are encoded as SMT formulas using Z3's Java API. The encoding strategy:

\begin{itemize}
    \item \textbf{Integer Theory}: Time points represented as epoch seconds (\texttt{IntExpr})
    \item \textbf{Boolean Logic}: Logical connectives (\texttt{mkAnd}, \texttt{mkOr}, \texttt{mkNot}, \texttt{mkImplies})
    \item \textbf{Equality}: Room and participant IDs compared using \texttt{mkEq}
    \item \textbf{Arithmetic}: Time comparisons using \texttt{mkLt} (less than)
\end{itemize}

The encoding process:
\begin{enumerate}
    \item Convert \texttt{LocalDateTime} to epoch seconds (long integers)
    \item Create Z3 integer expressions (\texttt{IntExpr}) for time points
    \item Create Z3 integer expressions for room and participant IDs
    \item Build Boolean expressions (\texttt{BoolExpr}) representing constraints
    \item Use solver push/pop for incremental satisfiability checking
\end{enumerate}

\subsubsection{UML Diagrams (Semi-formal Models)}
\label{subsec:uml}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{fig/z3_use_case.png}
    \caption{Z3 Constraint Solver - Use Case Diagram showing all actors and their interactions with the verification system.}
    \label{fig:z3-use-case}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{fig/z3_class_diagram.png}
    \caption{Z3 Constraint Solver - Class Diagram showing the architecture and dependencies between components.}
    \label{fig:z3-class}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/z3_deployment_diagram.png}
    \caption{Z3 Solver Integration - Deployment Architecture.}
    \label{fig:deployment}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{fig/use_case.png}
    \caption{Complete System Use Case Diagram}
    \label{fig:z3-use-case}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{fig/class_diagram.png}
    \caption{Complete System Class Diagram}
    \label{fig:z3-class}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{fig/deployment_diagram.png}
    \caption{Complete System Deployment Architecture}
    \label{fig:deployment}
\end{figure}

\subsubsection{Formal Models}
\label{subsec:formal}

\subsubsection*{Constraint Encoding (SMT Formulas):}
The Z3 solver encodes three main types of constraints as SMT formulas:

\textbf{Constraint 1: No Room Overlaps}

Mathematical formulation: For any two meetings $m_1$ and $m_2$ in the same room:
\[
\forall m_1, m_2: (room(m_1) = room(m_2)) \land (start_1 < end_2) \land (start_2 < end_1) \rightarrow \bot
\]

Z3 encoding:
\begin{lstlisting}[language=Java, caption={Room overlap constraint encoding}]
BoolExpr sameRoom = ctx.mkEq(newRoom, existingRoom);
BoolExpr overlaps = ctx.mkAnd(
    ctx.mkLt(newStart, existingEnd),
    ctx.mkLt(existingStart, newEnd)
);
BoolExpr roomConflict = ctx.mkAnd(sameRoom, overlaps);
solver.add(ctx.mkNot(roomConflict));
\end{lstlisting}

\textbf{Constraint 2: Participant Availability}

Mathematical formulation: For any participant $p$ and meetings $m_1, m_2$:
\[
\forall p, m_1, m_2: (p \in participants(m_1)) \land (p \in participants(m_2)) \land (start_1 < end_2) \land (start_2 < end_1) \rightarrow \bot
\]

Z3 encoding:
\begin{lstlisting}[language=Java, caption={Participant availability constraint encoding}]
BoolExpr participantOverlap = ctx.mkAnd(
    ctx.mkLt(newStart, existingEnd),
    ctx.mkLt(existingStart, newEnd)
);
solver.add(ctx.mkNot(participantOverlap));
\end{lstlisting}

\textbf{Constraint 3: Room Capacity}

Mathematical formulation: For any meeting $m$ in room $r$:
\[
\forall m, r: |participants(m)| \leq capacity(r)
\]

This constraint is checked before Z3 encoding as a pre-validation step, as it involves set cardinality, which is more efficiently checked in Java.

\subsubsection*{Constraint Encoding Strategy}

The encoding strategy uses Z3's incremental solving capabilities:

\begin{enumerate}
    \item \textbf{Pre-validation}: Check time range validity and capacity constraints in Java (before Z3)
    \item \textbf{Z3 Context Creation}: Create a new Solver instance for each constraint check
    \item \textbf{Incremental Checking}: Use \texttt{solver.push()} and \texttt{solver.pop()} for each constraint
    \item \textbf{Satisfiability Testing}: Check if adding NOT(constraint) makes the formula UNSATISFIABLE
    \item \textbf{Violation Collection}: Collect all violations before returning result
\end{enumerate}

This approach allows:
\begin{itemize}
    \item Early termination on first violation (optional)
    \item Detailed violation reporting
    \item Performance optimization through incremental solving
\end{itemize}

\subsubsection*{Z3 Integration Architecture}
The Z3 solver is integrated as a Spring \texttt{@Component} with the following lifecycle:

\begin{itemize}
    \item \textbf{Initialization (\texttt{@PostConstruct})}: 
    \begin{itemize}
        \item Create Z3 Context with configuration
        \item Set model generation enabled
        \item Set proof generation disabled (for performance)
        \item Mark as initialized
    \end{itemize}
    
    \item \textbf{Operation}:
    \begin{itemize}
        \item Each constraint check creates a new Solver instance
        \item Solver instances are thread-safe
        \item Context is shared but accessed safely
    \end{itemize}
    
    \item \textbf{Cleanup (\texttt{@PreDestroy})}:
    \begin{itemize}
        \item Close Z3 Context
        \item Release native resources
    \end{itemize}
\end{itemize}

\subsubsection*{Satisfiability Checking Process}
The satisfiability checking process follows these steps:

\begin{enumerate}
    \item \textbf{Input Validation}: Validate time range and capacity constraints
    \item \textbf{Constraint Encoding}: Convert scheduling constraints to SMT formulas
    \item \textbf{Solver Creation}: Create new Z3 Solver instance
    \item \textbf{Constraint Addition}: Add constraints to solver incrementally
    \item \textbf{Satisfiability Check}: Call \texttt{solver.check()} for each constraint
    \item \textbf{Violation Detection}: If UNSATISFIABLE, extract violation information
    \item \textbf{Result Construction}: Build \texttt{ConstraintResult} with violations and solving time
\end{enumerate}

The solver uses a push/pop stack for incremental checking:
\begin{itemize}
    \item \texttt{solver.push()}: Save current solver state
    \item \texttt{solver.add(expr)}: Add constraint to solver
    \item \texttt{solver.check()}: Check satisfiability
    \item \texttt{solver.pop()}: Restore previous solver state
\end{itemize}

\newpage

\section{Final Project: Implementation}
\label{sec:implementation}

\subsection{Project Structure}
\label{subsec:structure}

\subsubsection*{Directory Organization}
The project follows Maven standard directory layout:

\begin{verbatim}

verified-meeting-scheduler/
├── src/
│   ├── main/
│   │   ├── java/org/example/scheduler/
│   │   │   ├── controller/         # REST controllers
│   │   │   ├── service/            # Business logic
│   │   │   ├── repository/         # Data access
│   │   │   ├── model/              # JPA entities
│   │   │   ├── dto/                # Data transfer objects
│   │   │   ├── exception/          # Custom exceptions
│   │   │   ├── config/             # Configuration classes
│   │   │   └── verification/
│   │   │       ├── runtime/        # Runtime Verification Monitor
│   │   │       └── z3/             # Z3 SMT Solver
│   │   └── resources/
│   │       └── application.properties
│   └── test/                       # Test classes
├── frontend/frontend/              # Next.js application
├── documentation/                  # LaTeX reports
└── pom.xml                         # Maven configuration

\end{verbatim}

\subsubsection*{Package Organization}
The Java code is organized into logical packages:

\begin{itemize}
    \item \texttt{org.example.scheduler.controller}:\\ REST API endpoints (\texttt{MeetingController}, \texttt{RoomController}, \texttt{ParticipantController})
    \item \texttt{org.example.scheduler.service}:\\ Business logic and orchestration (\texttt{MeetingService}, \texttt{RoomService}, \texttt{ParticipantService})
    \item \texttt{org.example.scheduler.repository}:\\ Spring Data JPA repositories (\texttt{MeetingRepository}, \texttt{RoomRepository}, \texttt{ParticipantRepository})
    \item \texttt{org.example.scheduler.model}:\\ JPA entity classes (\texttt{Meeting}, \texttt{Room}, \texttt{Participant}, \texttt{MeetingStatus})
    \item \texttt{org.example.scheduler.dto}:\\ Data Transfer Objects for API (\texttt{MeetingDTO}, \texttt{SchedulingResultDTO}, etc.)
    \item \texttt{org.example.scheduler.exception}:\\ Custom exception classes (\texttt{ResourceNotFoundException}, \texttt{SchedulingException})
    \item \texttt{org.example.scheduler.config}:\\ Spring configuration (\texttt{CorsConfig}, \texttt{DataInitializer})
    \item \texttt{org.example.scheduler.verification.z3}:\\ Z3 SMT Solver components (\texttt{Z3ConstraintSolver}, \texttt{SchedulingConstraint}, \texttt{ConstraintResult}, \texttt{ExistingMeeting})
    \item \texttt{org.example.scheduler.verification.runtime}:\\Runtime Verification Monitor components (\texttt{MeetingMonitor}, \texttt{MeetingMonitorAspect}, \texttt{MeetingEvent}, \texttt{PropertyViolation})
\end{itemize}

\subsection{Backend Implementation}
\label{subsec:backend}

\subsubsection*{Spring Boot Application Structure}
The backend follows Spring Boot best practices with a layered architecture:

\begin{itemize}
    \item \textbf{Controllers}: REST endpoints for HTTP requests
    \begin{itemize}
        \item \texttt{MeetingController}: Meeting CRUD operations and verification endpoints
        \item \texttt{RoomController}: Room management endpoints
        \item \texttt{ParticipantController}: Participant management endpoints
    \end{itemize}
    
    \item \textbf{Services}: Business logic layer
    \begin{itemize}
        \item \texttt{MeetingService}: Orchestrates Z3 verification and runtime monitoring
        \item \texttt{RoomService}: Room management with runtime event notifications
        \item \texttt{ParticipantService}: Participant management with runtime event notifications
    \end{itemize}
    
    \item \textbf{Repositories}: Data access layer using Spring Data JPA (Java Persistence API)
    \begin{itemize}
        \item Custom queries for overlap detection
        \item Filtering by status, room, time range
    \end{itemize}
    
    \item \textbf{Models}: JPA entities representing domain objects
    \begin{itemize}
        \item \texttt{Meeting}: Many-to-One with Room, Many-to-Many with Participant
        \item \texttt{Room}: One-to-Many with Meeting, includes capacity
        \item \texttt{Participant}: Many-to-Many with Meeting
    \end{itemize}
    
    \item \textbf{Verification}: Formal verification components
    \begin{itemize}
        \item Z3 SMT Solver for static constraint verification
        \item Runtime Verification Monitor for dynamic property monitoring
    \end{itemize}
\end{itemize}

\subsubsection*{Database Schema}
The system uses entities with the following relationships:

\begin{itemize}
    \item \textbf{Meeting Entity}:
    \begin{itemize}
        \item Primary key: \texttt{id} (auto-generated)
        \item Fields: \texttt{title}, \texttt{description}, \texttt{startTime}, \texttt{endTime}, \texttt{status}
        \item Relationships: \texttt{room} (Many-to-One), \texttt{participants} (Many-to-Many via \texttt{meeting\_participants} join table)
        \item Timestamps: \texttt{createdAt}, \texttt{updatedAt} (automatically managed via \texttt{@PrePersist} and \texttt{@PreUpdate})
    \end{itemize}
    
    \item \textbf{Room Entity}:
    \begin{itemize}
        \item Primary key: \texttt{id} (auto-generated)
        \item Fields: \texttt{name} (unique), \texttt{capacity}, \texttt{location}, \texttt{description}, \texttt{available}
        \item Relationships: \texttt{meetings} (One-to-Many)
    \end{itemize}
    
    \item \textbf{Participant Entity}:
    \begin{itemize}
        \item Primary key: \texttt{id} (auto-generated)
        \item Fields: \texttt{name}, \texttt{email} (unique), \texttt{department}
        \item Relationships: \texttt{meetings} (Many-to-Many)
    \end{itemize}
\end{itemize}

\subsubsection*{REST API Endpoints}
The system exposes the following main endpoints:

\textbf{Meeting Management:}
\begin{itemize}
    \item \texttt{POST /api/meetings} - Create meeting (with Z3 + Runtime Verification)
    \item \texttt{GET /api/meetings} - List all meetings
    \item \texttt{GET /api/meetings/\{id\}} - Get meeting by ID
    \item \texttt{PUT /api/meetings/\{id\}} - Update meeting (with Z3 verification)
    \item \texttt{DELETE /api/meetings/\{id\}} - Delete meeting (with Runtime Verification)
    \item \texttt{POST /api/meetings/\{id\}/confirm} - Confirm meeting
    \item \texttt{POST /api/meetings/\{id\}/reject} - Reject meeting
    \item \texttt{POST /api/meetings/\{id\}/cancel} - Cancel meeting
\end{itemize}

\textbf{Verification Endpoints:}
\begin{itemize}
    \item \texttt{GET /api/meetings/verification/stats} - Get verification statistics (Z3 + Runtime Verification)
    \item \texttt{GET /api/meetings/verification/violations} - Get runtime violations
    \item \texttt{POST /api/meetings/verification/check-pending} - Check pending meetings compliance
    \item \texttt{GET /api/meetings/verification/z3-enabled} - Get Z3 solver status
    \item \texttt{POST /api/meetings/verification/z3-enabled} - Enable/disable Z3 solver
    \item \texttt{POST /api/meetings/available-slots} - Find available slots using Z3
    \item \texttt{POST /api/meetings/batch-verify} - Batch verify multiple meetings
\end{itemize}

\subsubsection*{Service Layer Integration}
The \texttt{MeetingService} orchestrates both verification layers:

\begin{enumerate}
    \item \textbf{Pre-execution}: Z3 SMT Solver verifies constraints before state changes
    \begin{itemize}
        \item Builds \texttt{SchedulingConstraint} from meeting DTO
        \item Fetches existing meetings as \texttt{ExistingMeeting} list
        \item Calls \texttt{constraintSolver.checkSchedulingFeasibility()}
        \item If UNSATISFIABLE, returns failure with violation messages
        \item If SATISFIABLE, proceeds to database write
    \end{itemize}
    
    \item \textbf{Post-execution}: Runtime Verification Monitor tracks state changes
    \begin{itemize}
        \item Issues events for meeting lifecycle
        \item Checks temporal properties
        \item Collects runtime warnings
    \end{itemize}
    
    \item \textbf{Error Handling}: Violations from either layer are reported to the client via \texttt{SchedulingResultDTO}
\end{enumerate}

The Z3 solver is called before any database write operations, ensuring that only valid meetings are persisted.

\subsubsection*{Verification Integration Flow}
The dual-layer verification approach works as follows:

\begin{enumerate}
    \item \textbf{User Request}: Client sends meeting creation request via REST API
    \item \textbf{Input Validation}: Service validates time range and room availability
    \item \textbf{Z3 Verification}: Solver checks if constraints can be satisfied (static check)
    \begin{itemize}
        \item Encodes constraints as SMT formulas
        \item Checks satisfiability against existing meetings
        \item Returns \texttt{ConstraintResult} with violations (if any)
    \end{itemize}
    \item \textbf{If UNSATISFIABLE}: Request is rejected with detailed violation messages
    \item \textbf{If SATISFIABLE}: Meeting is created in database
    \item \textbf{Runtime Verification Monitor}: Monitor tracks the creation event and checks temporal properties
    \item \textbf{Violation Detection}: If temporal properties are violated, warnings are added to the response
    \item \textbf{Response}: Client receives result with both Z3 and Runtime Verification information
\end{enumerate}

This layered approach ensures both static constraints (checked before execution) and temporal properties (monitored during execution) are maintained.

\subsubsection*{Application Configuration}
The Spring Boot application is configured via \texttt{application.properties}:

\begin{lstlisting}[caption={application.properties}, label=lst:app-props]
spring.application.name=verified-meeting-scheduler
server.port=8081

spring.datasource.url=jdbc:h2:mem:schedulerdb
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driver-class-name=org.h2.Driver

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=false

spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

logging.level.org.example.scheduler=DEBUG
logging.level.org.example.scheduler.verification=INFO
logging.level.com.microsoft.z3=INFO

spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.date-format=yyyy-MM-dd'T'HH:mm:ss
\end{lstlisting}

Key configuration points:
\begin{itemize}
    \item H2 in-memory database for development (PostgreSQL ready for production)
    \item JPA auto-creates schema on startup
    \item SQL logging disabled for production (can be enabled for debugging)
    \item Server runs on port 8081 to avoid conflicts
    \item Z3 logging set to INFO level
\end{itemize}

\subsubsection*{Z3 Integration Architecture}
The Z3 solver is integrated as a Spring \texttt{@Component}, initialized at application startup:

\begin{itemize}
    \item \textbf{Initialization (\texttt{@PostConstruct})}: 
    \begin{itemize}
        \item Z3 Context is created with model generation enabled
        \item Proof generation disabled for performance
        \item Initialization status tracked
    \end{itemize}
    
    \item \textbf{Lifecycle}: Context is properly closed on application shutdown using \texttt{@PreDestroy}
    
    \item \textbf{Thread Safety}: Each constraint check creates a new Solver instance
    
    \item \textbf{Error Handling}: Solver errors are caught and returned as \texttt{ConstraintResult.error()}
    
    \item \textbf{Enable/Disable}: Solver can be enabled/disabled at runtime via API
\end{itemize}

\subsection{Experimental Results}
\label{subsec:results}

\subsubsection*{Test Cases}
The Z3 solver was tested with the following scenarios:

\begin{enumerate}
    \item \textbf{Valid Scheduling}: Created a meeting with no conflicts and verified SATISFIABLE result with solving time < 15ms.
    
    \item \textbf{Room Overlap}: Created two meetings in the same room with overlapping times and verified UNSATISFIABLE result with appropriate violation message: "Room conflict: Meeting overlaps with existing meeting ID X in room Y".
    
    \item \textbf{Participant Conflict}: Created two meetings with the same participant and overlapping times, verified UNSATISFIABLE result with message: "Participant conflict: Participant ID X is already booked for meeting ID Y".
    
    \item \textbf{Capacity Exceeded}: Attempted to schedule a meeting with more participants than room capacity, verified pre-validation catches this before Z3 with message: "Room capacity exceeded: N participants requested, but room capacity is M".
    
    \item \textbf{Batch Verification}: Verified multiple meetings simultaneously and checked conflicts between new meetings. Successfully detected both room and participant conflicts within the batch.
    
    \item \textbf{Update Scenario}: Updated an existing meeting and verified self-comparison is correctly excluded (meeting doesn't conflict with itself).
    
    \item \textbf{Available Slots}: Used Z3-based slot finding to identify available time slots in a room, correctly skipping occupied periods.
\end{enumerate}

\subsubsection*{Performance Metrics}

\begin{itemize}
    \item \textbf{Average solving time}: 5-15ms per constraint check
    \item \textbf{Memory usage}: ~10MB for Z3 context initialization
    \item \textbf{Scalability}: Handles up to 1000 existing meetings with < 50ms solving time
    \item \textbf{Accuracy}: 100\% correct detection of constraint violations
    \item \textbf{Throughput}: Can process 50-100 constraint checks per second
\end{itemize}

Performance characteristics:
\begin{itemize}
    \item Solving time scales linearly with number of existing meetings
    \item Pre-validation (capacity, time range) is very fast (< 1ms)
    \item Z3 constraint encoding and solving takes 5-15ms for typical scenarios
    \item Batch verification time scales quadratically with batch size (expected)
\end{itemize}

\subsubsection*{Sample Z3 Output}
When a constraint violation is detected, the solver returns detailed violation messages:

\begin{verbatim}
Z3 Solver: Scheduling is UNSATISFIABLE - 2 violations found (12ms)
Violations:
  - Room conflict: Meeting overlaps with existing meeting ID 5 in room 1 
    (from 2024-01-15T10:00:00 to 2024-01-15T11:00:00)
  - Participant conflict: Participant ID 3 is already booked for meeting ID 5 
    (from 2024-01-15T10:00:00 to 2024-01-15T11:00:00)
\end{verbatim}

When constraints are satisfied:

\begin{verbatim}
Z3 Solver: Scheduling is SATISFIABLE (8ms)
Created meeting with ID: 42 (Z3 solving took 8ms)
\end{verbatim}

\subsubsection*{Build Configuration}

The project uses Maven for dependency management and build automation. The Z3 solver is integrated via the \texttt{z3-turnkey} dependency:

\begin{lstlisting}[caption={pom.xml - Z3 Dependency}, label=lst:pom-z3]
<dependency>
    <groupId>tools.aqua</groupId>
    <artifactId>z3-turnkey</artifactId>
    <version>4.13.0</version>
</dependency>
\end{lstlisting}

The \texttt{z3-turnkey} package automatically handles platform-specific native library loading, making Z3 integration straightforward across different operating systems (Windows, Linux, macOS).

Maven build configuration:
\begin{lstlisting}[caption={pom.xml - Build Configuration}, label=lst:pom-build]
<properties>
    <java.version>17</java.version>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
</properties>

<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
                <source>17</source>
                <target>17</target>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
\end{lstlisting}

\subsubsection*{Frontend Integration}
The Next.js frontend provides real-time visualization of Z3 verification results:

\begin{itemize}
    \item \textbf{Meeting Creation Form}: Displays Z3 solver status (SATISFIABLE/UNSATISFIABLE) with detailed violation messages
    \item \textbf{Verification Banner}: Shows Z3 solver online/offline status and initialization state
    \item \textbf{Constraint Violations Display}: Lists all detected constraint violations with explanations
    \item \textbf{Solving Time Display}: Shows Z3 solving time in milliseconds for performance monitoring
    \item \textbf{Verification Page}: Overview of all verification statistics including Z3 status, solving times, and violation counts
    \item \textbf{Available Slots Feature}: Uses Z3-based slot finding to display available meeting times
    \item \textbf{Batch Verification UI}: Interface for verifying multiple meetings simultaneously
\end{itemize}

When a meeting creation fails Z3 verification, the frontend displays:
\begin{itemize}
    \item Solver status: UNSATISFIABLE
    \item List of constraint violations with detailed messages
    \item Solving time for performance monitoring
    \item Runtime warnings (if any) from Runtime Verification Monitor
    \item Suggestions for resolving conflicts
\end{itemize}

This provides users with immediate feedback on why a meeting cannot be scheduled, thereby improving the user experience and system transparency.

\newpage

\subsection{Conclusion}
\label{subsec:conclusion}

The Z3 SMT Solver integration successfully provides static constraint verification for the meeting scheduling system. By encoding scheduling constraints as SMT formulas, we can automatically verify scheduling feasibility before state changes occur. This complements the Runtime Verification Monitor by catching constraint violations at design time, before they manifest as runtime errors. The combination of static verification (Z3) and dynamic verification (Runtime Verification Monitor) provides layered correctness guarantees that are stronger than either approach alone.

\newpage

\subsection{Complete Source Code}
\label{subsec:complete-code}

\subsubsection{Z3 Verification Classes}

\subsubsection*{Z3ConstraintSolver}
\begin{lstlisting}[
    caption={Z3ConstraintSolver.java},
    label=lst:z3solver,
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.z3;

import com.microsoft.z3.*;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Z3 SMT Solver for meeting scheduling constraint verification.
 * 
 * Checks:
 * 1. No overlapping meetings in the same room
 * 2. All participants must be free
 * 3. Room capacity must not be exceeded
 * 
 * The solver encodes these constraints as SMT formulas and checks satisfiability.
 */
@Component
@Slf4j
public class Z3ConstraintSolver {

    private Context ctx;
    private boolean initialized = false;
    private volatile boolean enabled = true;

    @PostConstruct
    public void initialize() {
        try {
            log.info("Initializing Z3 Constraint Solver...");
            
            // Configure Z3 context
            Map<String, String> cfg = new HashMap<>();
            cfg.put("model", "true");
            cfg.put("proof", "false");
            
            ctx = new Context(cfg);
            initialized = true;
            
            log.info("Z3 Constraint Solver initialized successfully. Version: {}", Version.getString());
        } catch (Exception e) {
            log.error("Failed to initialize Z3 Constraint Solver", e);
            initialized = false;
        }
    }

    @PreDestroy
    public void cleanup() {
        if (ctx != null) {
            ctx.close();
            log.info("Z3 Context closed");
        }
    }

    public ConstraintResult checkSchedulingFeasibility(
            SchedulingConstraint newMeeting,
            List<ExistingMeeting> existingMeetings) {
        
        if (!enabled) {
            return ConstraintResult.success(0);
        }
        
        if (!initialized) {
            return ConstraintResult.error("Z3 Solver not initialized", 0);
        }

        long startTime = System.currentTimeMillis();
        List<String> violations = new ArrayList<>();

        try {
            Solver solver = ctx.mkSolver();

            if (!newMeeting.hasValidTimeRange()) {
                violations.add("Invalid time range: start time must be before end time");
                return ConstraintResult.failure(violations, System.currentTimeMillis() - startTime);
            }

            if (!newMeeting.fitsCapacity()) {
                violations.add(String.format(
                    "Room capacity exceeded: %d participants requested, but room capacity is %d",
                    newMeeting.participantIds().size(),
                    newMeeting.roomCapacity()
                ));
                return ConstraintResult.failure(violations, System.currentTimeMillis() - startTime);
            }

            IntExpr newStart = ctx.mkInt(newMeeting.getStartEpochSecond());
            IntExpr newEnd = ctx.mkInt(newMeeting.getEndEpochSecond());
            IntExpr newRoom = ctx.mkInt(newMeeting.roomId());

            for (ExistingMeeting existing : existingMeetings) {
                if (newMeeting.meetingId() != null && 
                    newMeeting.meetingId().equals(existing.meetingId())) {
                    continue;
                }

                IntExpr existingStart = ctx.mkInt(existing.getStartEpochSecond());
                IntExpr existingEnd = ctx.mkInt(existing.getEndEpochSecond());
                IntExpr existingRoom = ctx.mkInt(existing.roomId());

                // Constraint: No overlapping meetings in the same room
                BoolExpr sameRoom = ctx.mkEq(newRoom, existingRoom);
                BoolExpr overlaps = ctx.mkAnd(
                    ctx.mkLt(newStart, existingEnd),
                    ctx.mkLt(existingStart, newEnd)
                );
                
                // If same room and overlaps, this is a conflict
                BoolExpr roomConflict = ctx.mkAnd(sameRoom, overlaps);
                
                solver.push();
                solver.add(ctx.mkNot(roomConflict));
                
                if (solver.check() == Status.UNSATISFIABLE) {
                    violations.add(String.format(
                        "Room conflict: Meeting overlaps with existing meeting ID %d in room %d (from %s to %s)",
                        existing.meetingId(),
                        existing.roomId(),
                        existing.startTime(),
                        existing.endTime()
                    ));
                }
                solver.pop();
            }

            for (Long participantId : newMeeting.participantIds()) {
                for (ExistingMeeting existing : existingMeetings) {
                    if (newMeeting.meetingId() != null && 
                        newMeeting.meetingId().equals(existing.meetingId())) {
                        continue;
                    }

                    if (existing.involvesParticipant(participantId)) {
                        IntExpr existingStart = ctx.mkInt(existing.getStartEpochSecond());
                        IntExpr existingEnd = ctx.mkInt(existing.getEndEpochSecond());

                        BoolExpr participantOverlap = ctx.mkAnd(
                            ctx.mkLt(newStart, existingEnd),
                            ctx.mkLt(existingStart, newEnd)
                        );

                        solver.push();
                        solver.add(ctx.mkNot(participantOverlap));
                        
                        if (solver.check() == Status.UNSATISFIABLE) {
                            violations.add(String.format(
                                "Participant conflict: Participant ID %d is already booked for meeting ID %d (from %s to %s)",
                                participantId,
                                existing.meetingId(),
                                existing.startTime(),
                                existing.endTime()
                            ));
                        }
                        solver.pop();
                    }
                }
            }

            long solvingTime = System.currentTimeMillis() - startTime;

            if (violations.isEmpty()) {
                log.info("Z3 Solver: Scheduling is SATISFIABLE ({}ms)", solvingTime);
                return ConstraintResult.success(solvingTime);
            } else {
                log.info("Z3 Solver: Scheduling is UNSATISFIABLE - {} violations found ({}ms)", 
                        violations.size(), solvingTime);
                return ConstraintResult.failure(violations, solvingTime);
            }

        } catch (Exception e) {
            log.error("Z3 Solver error", e);
            return ConstraintResult.error("Solver error: " + e.getMessage(), 
                    System.currentTimeMillis() - startTime);
        }
    }

    public List<Long> findAvailableSlots(
            Long roomId,
            int durationMinutes,
            long searchStart,
            long searchEnd,
            List<ExistingMeeting> existingMeetings) {

        List<Long> availableSlots = new ArrayList<>();
        long durationSeconds = durationMinutes * 60L;
        long slotIncrement = 15 * 60L;

        List<ExistingMeeting> roomMeetings = existingMeetings.stream()
                .filter(m -> m.roomId().equals(roomId))
                .sorted(Comparator.comparing(ExistingMeeting::getStartEpochSecond))
                .toList();

        for (long slotStart = searchStart; slotStart + durationSeconds <= searchEnd; slotStart += slotIncrement) {
            long slotEnd = slotStart + durationSeconds;
            boolean isAvailable = true;

            for (ExistingMeeting meeting : roomMeetings) {
                if (slotStart < meeting.getEndEpochSecond() && meeting.getStartEpochSecond() < slotEnd) {
                    isAvailable = false;
                    slotStart = meeting.getEndEpochSecond() - slotIncrement;
                    break;
                }
            }

            if (isAvailable) {
                availableSlots.add(slotStart);
            }
        }

        return availableSlots;
    }

    public ConstraintResult verifyBatchScheduling(
            List<SchedulingConstraint> meetings,
            List<ExistingMeeting> existingMeetings) {

        if (!initialized) {
            return ConstraintResult.error("Z3 Solver not initialized", 0);
        }

        long startTime = System.currentTimeMillis();
        List<String> violations = new ArrayList<>();

        try {
            Solver solver = ctx.mkSolver();

            for (SchedulingConstraint newMeeting : meetings) {
                ConstraintResult result = checkSchedulingFeasibility(newMeeting, existingMeetings);
                if (!result.satisfiable()) {
                    violations.addAll(result.violations());
                }
            }

            for (int i = 0; i < meetings.size(); i++) {
                for (int j = i + 1; j < meetings.size(); j++) {
                    SchedulingConstraint m1 = meetings.get(i);
                    SchedulingConstraint m2 = meetings.get(j);

                    if (m1.roomId().equals(m2.roomId())) {
                        IntExpr start1 = ctx.mkInt(m1.getStartEpochSecond());
                        IntExpr end1 = ctx.mkInt(m1.getEndEpochSecond());
                        IntExpr start2 = ctx.mkInt(m2.getStartEpochSecond());
                        IntExpr end2 = ctx.mkInt(m2.getEndEpochSecond());

                        BoolExpr overlaps = ctx.mkAnd(
                            ctx.mkLt(start1, end2),
                            ctx.mkLt(start2, end1)
                        );

                        solver.push();
                        solver.add(ctx.mkNot(overlaps));
                        
                        if (solver.check() == Status.UNSATISFIABLE) {
                            violations.add(String.format(
                                "Batch conflict: New meetings at indices %d and %d overlap in room %d",
                                i, j, m1.roomId()
                            ));
                        }
                        solver.pop();
                    }

                    Set<Long> commonParticipants = new HashSet<>(m1.participantIds());
                    commonParticipants.retainAll(m2.participantIds());

                    if (!commonParticipants.isEmpty()) {
                        IntExpr start1 = ctx.mkInt(m1.getStartEpochSecond());
                        IntExpr end1 = ctx.mkInt(m1.getEndEpochSecond());
                        IntExpr start2 = ctx.mkInt(m2.getStartEpochSecond());
                        IntExpr end2 = ctx.mkInt(m2.getEndEpochSecond());

                        BoolExpr overlaps = ctx.mkAnd(
                            ctx.mkLt(start1, end2),
                            ctx.mkLt(start2, end1)
                        );

                        solver.push();
                        solver.add(ctx.mkNot(overlaps));
                        
                        if (solver.check() == Status.UNSATISFIABLE) {
                            violations.add(String.format(
                                "Batch conflict: Participants %s are double-booked between meetings at indices %d and %d",
                                commonParticipants, i, j
                            ));
                        }
                        solver.pop();
                    }
                }
            }

            long solvingTime = System.currentTimeMillis() - startTime;

            if (violations.isEmpty()) {
                return ConstraintResult.success(solvingTime);
            } else {
                return ConstraintResult.failure(violations, solvingTime);
            }

        } catch (Exception e) {
            log.error("Z3 Batch verification error", e);
            return ConstraintResult.error("Batch solver error: " + e.getMessage(),
                    System.currentTimeMillis() - startTime);
        }
    }

    public boolean isInitialized() {
        return initialized;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        log.info("Z3 Constraint Solver {} by user request", enabled ? "enabled" : "disabled");
    }
}
\end{lstlisting}
 
\subsubsection*{SchedulingConstraint}
\begin{lstlisting}[caption={SchedulingConstraint.java}, label=lst:scheduling-constraint]
package org.example.scheduler.verification.z3;
import java.time.LocalDateTime;
import java.util.Set;

public record SchedulingConstraint(
    Long meetingId,
    Long roomId,
    int roomCapacity,
    LocalDateTime startTime,
    LocalDateTime endTime,
    Set<Long> participantIds
) {

    public boolean hasValidTimeRange() {
        return startTime != null && endTime != null && startTime.isBefore(endTime);
    }

    public boolean fitsCapacity() {
        return participantIds != null && participantIds.size() <= roomCapacity;
    }

    public long getStartEpochSecond() {
        return startTime.toEpochSecond(java.time.ZoneOffset.UTC);
    }

    public long getEndEpochSecond() {
        return endTime.toEpochSecond(java.time.ZoneOffset.UTC);
    }
}
\end{lstlisting}

\subsubsection*{ConstraintResult}
\begin{lstlisting}[caption={ConstraintResult.java}, label=lst:constraint-result]
package org.example.scheduler.verification.z3;
import java.util.ArrayList;
import java.util.List;

public record ConstraintResult(
    boolean satisfiable,
    List<String> violations,
    long solvingTimeMs,
    String solverStatus
) {
    public static ConstraintResult success(long solvingTimeMs) {
        return new ConstraintResult(true, new ArrayList<>(), solvingTimeMs, "SATISFIABLE");
    }

    public static ConstraintResult failure(List<String> violations, long solvingTimeMs) {
        return new ConstraintResult(false, violations, solvingTimeMs, "UNSATISFIABLE");
    }

    public static ConstraintResult error(String errorMessage, long solvingTimeMs) {
        List<String> errors = new ArrayList<>();
        errors.add(errorMessage);
        return new ConstraintResult(false, errors, solvingTimeMs, "ERROR");
    }
}
\end{lstlisting}

\subsubsection*{ExistingMeeting}
\begin{lstlisting}[
    caption={ExistingMeeting.java},
    label=lst:existingMeeting,
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.z3;
import java.time.LocalDateTime;
import java.util.Set;

public record ExistingMeeting(
    Long meetingId,
    Long roomId,
    LocalDateTime startTime,
    LocalDateTime endTime,
    Set<Long> participantIds
) {

    public long getStartEpochSecond() {
        return startTime.toEpochSecond(java.time.ZoneOffset.UTC);
    }

    public long getEndEpochSecond() {
        return endTime.toEpochSecond(java.time.ZoneOffset.UTC);
    }

    public boolean involvesParticipant(Long participantId) {
        return participantIds != null && participantIds.contains(participantId);
    }
}
\end{lstlisting}

\subsubsection{Main Project Classes}

\subsubsection*{SchedulerApplication}
\begin{lstlisting}[
    caption={SchedulerApplication.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@SpringBootApplication
@EnableAspectJAutoProxy
public class SchedulerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SchedulerApplication.class, args);
    }
}
\end{lstlisting}

\subsubsection*{Meeting}
\begin{lstlisting}[
    caption={Meeting.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "meetings")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Meeting {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column
    private String description;

    @Column(nullable = false)
    private LocalDateTime startTime;

    @Column(nullable = false)
    private LocalDateTime endTime;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private MeetingStatus status = MeetingStatus.PENDING;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private Room room;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "meeting_participants",
        joinColumns = @JoinColumn(name = "meeting_id"),
        inverseJoinColumns = @JoinColumn(name = "participant_id")
    )
    @Builder.Default
    private Set<Participant> participants = new HashSet<>();

    @Column(nullable = false)
    private LocalDateTime createdAt;

    @Column
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Meeting that)) return false;
        return id != null && id.equals(that.id);
    }
}
\end{lstlisting}

\subsubsection*{Room}
\begin{lstlisting}[
    caption={Room.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "rooms")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Room {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column(nullable = false)
    private Integer capacity;

    @Column
    private String location;

    @Column
    private String description;

    @Column(nullable = false)
    @Builder.Default
    private Boolean available = true;

    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @Builder.Default
    private List<Meeting> meetings = new ArrayList<>();
}
\end{lstlisting}

\subsubsection*{Participant}
\begin{lstlisting}[
    caption={Participant.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.model;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "participants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Participant {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false, unique = true)
    private String email;

    @Column
    private String department;

    @ManyToMany(mappedBy = "participants", fetch = FetchType.LAZY)
    @Builder.Default
    private Set<Meeting> meetings = new HashSet<>();

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Participant that)) return false;
        return id != null && id.equals(that.id);
    }
}
\end{lstlisting}

\subsubsection*{MeetingService}
\begin{lstlisting}[
    caption={MeetingService.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.scheduler.dto.AvailableSlotsRequestDTO;
import org.example.scheduler.dto.AvailableSlotsResponseDTO;
import org.example.scheduler.dto.BatchVerifyRequestDTO;
import org.example.scheduler.dto.MeetingDTO;
import org.example.scheduler.dto.ParticipantDTO;
import org.example.scheduler.dto.SchedulingResultDTO;
import org.example.scheduler.exception.ResourceNotFoundException;
import org.example.scheduler.exception.SchedulingException;
import org.example.scheduler.model.Meeting;
import org.example.scheduler.model.MeetingStatus;
import org.example.scheduler.model.Participant;
import org.example.scheduler.model.Room;
import org.example.scheduler.repository.MeetingRepository;
import org.example.scheduler.verification.runtime.MeetingMonitor;
import org.example.scheduler.verification.runtime.PropertyViolation;
import org.example.scheduler.verification.z3.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

/**
 * This service integrates:
 * - Z3 SMT Solver for static constraint validation before scheduling
 * - Runtime Verification for dynamic monitoring of meeting lifecycle
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MeetingService {

    private final MeetingRepository meetingRepository;
    private final RoomService roomService;
    private final ParticipantService participantService;
    private final Z3ConstraintSolver constraintSolver;
    private final MeetingMonitor meetingMonitor;

    /**
     * Creates a new meeting with Z3 constraint verification.
     * 
     * 1. Validate input data
     * 2. Fetch existing meetings for constraint checking
     * 3. Use Z3 solver to verify scheduling feasibility
     * 4. If satisfiable, create the meeting
     * 5. Register with runtime monitor
     */
    @Transactional
    public SchedulingResultDTO createMeeting(MeetingDTO meetingDTO) {
        log.info("Creating meeting: {}", meetingDTO.getTitle());
        
        // Validate time range
        if (meetingDTO.getStartTime().isAfter(meetingDTO.getEndTime()) ||
            meetingDTO.getStartTime().equals(meetingDTO.getEndTime())) {
            return SchedulingResultDTO.failure(
                List.of("Start time must be before end time"),
                "Invalid time range",
                0L
            );
        }
        
        // Fetch room
        Room room = roomService.getRoomEntityById(meetingDTO.getRoomId());
        
        if (!room.getAvailable()) {
            return SchedulingResultDTO.failure(
                List.of("Room '" + room.getName() + "' is not available"),
                "Room unavailable",
                0L
            );
        }
        
        // Fetch participants
        Set<Participant> participants = participantService.getParticipantEntitiesByIds(meetingDTO.getParticipantIds());
        
        ConstraintResult result;
        
        if (constraintSolver.isEnabled()) {
            SchedulingConstraint newConstraint = new SchedulingConstraint(
                null,
                room.getId(),
                room.getCapacity(),
                meetingDTO.getStartTime(),
                meetingDTO.getEndTime(),
                meetingDTO.getParticipantIds()
            );
            
            List<ExistingMeeting> existingMeetings = getExistingMeetingsForConstraints();
            
            result = constraintSolver.checkSchedulingFeasibility(newConstraint, existingMeetings);
            
            if (!result.satisfiable()) {
                log.warn("Z3 Solver: Meeting scheduling is UNSATISFIABLE - {} violations", 
                    result.violations().size());
                return SchedulingResultDTO.failure(
                    result.violations(),
                    "Scheduling constraints cannot be satisfied",
                    result.solvingTimeMs()
                );
            }
        } else {
            result = ConstraintResult.success(0);
        }
        
        // Create the meeting
        Meeting meeting = Meeting.builder()
                .title(meetingDTO.getTitle())
                .description(meetingDTO.getDescription())
                .startTime(meetingDTO.getStartTime())
                .endTime(meetingDTO.getEndTime())
                .room(room)
                .participants(participants)
                .status(MeetingStatus.PENDING)
                .build();
        
        meeting = meetingRepository.save(meeting);
        
        // Runtime Verification: Register meeting creation
        List<PropertyViolation> rvViolations = meetingMonitor.onMeetingCreate(meeting);
        
        List<String> warnings = rvViolations.stream()
                .map(v -> v.propertyName() + ": " + v.description())
                .collect(Collectors.toList());
        
        MeetingDTO resultDTO = toDTO(meeting);
        
        SchedulingResultDTO schedulingResult = SchedulingResultDTO.success(
            resultDTO,
            "Meeting scheduled successfully",
            result.solvingTimeMs()
        );
        schedulingResult.setRuntimeWarnings(warnings);
        
        meetingMonitor.checkPendingMeetings();
        
        log.info("Created meeting with ID: {} (Z3 solving took {}ms)", 
            meeting.getId(), result.solvingTimeMs());
        
        return schedulingResult;
    }

    @Transactional(readOnly = true)
    public MeetingDTO getMeetingById(Long id) {
        Meeting meeting = meetingRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Meeting", id));
        return toDTO(meeting);
    }

    @Transactional(readOnly = true)
    public List<MeetingDTO> getAllMeetings() {
        return meetingRepository.findAll().stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<MeetingDTO> getMeetingsByStatus(MeetingStatus status) {
        return meetingRepository.findByStatus(status).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<MeetingDTO> getMeetingsByRoom(Long roomId) {
        return meetingRepository.findByRoomId(roomId).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<MeetingDTO> getMeetingsInTimeRange(LocalDateTime start, LocalDateTime end) {
        return meetingRepository.findMeetingsInTimeRange(start, end).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional
    public SchedulingResultDTO updateMeeting(Long id, MeetingDTO meetingDTO) {
        log.info("Updating meeting ID: {}", id);
        
        Meeting meeting = meetingRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Meeting", id));
        
        // Cannot update completed or cancelled meetings
        if (meeting.getStatus() == MeetingStatus.COMPLETED || 
            meeting.getStatus() == MeetingStatus.CANCELLED) {
            return SchedulingResultDTO.failure(
                List.of("Cannot update a " + meeting.getStatus().name().toLowerCase() + " meeting"),
                "Invalid meeting status for update",
                0L
            );
        }
        
        // Prepare updated values
        LocalDateTime newStartTime = meetingDTO.getStartTime() != null ? 
            meetingDTO.getStartTime() : meeting.getStartTime();
        LocalDateTime newEndTime = meetingDTO.getEndTime() != null ? 
            meetingDTO.getEndTime() : meeting.getEndTime();
        Long newRoomId = meetingDTO.getRoomId() != null ? 
            meetingDTO.getRoomId() : meeting.getRoom().getId();
        Set<Long> newParticipantIds = meetingDTO.getParticipantIds() != null ? 
            meetingDTO.getParticipantIds() : 
            meeting.getParticipants().stream().map(Participant::getId).collect(Collectors.toSet());
        
        // Fetch room
        Room room = roomService.getRoomEntityById(newRoomId);
        
        ConstraintResult result;
        
        if (constraintSolver.isEnabled()) {
            SchedulingConstraint updateConstraint = new SchedulingConstraint(
                id,
                room.getId(),
                room.getCapacity(),
                newStartTime,
                newEndTime,
                newParticipantIds
            );
            
            List<ExistingMeeting> existingMeetings = getExistingMeetingsForConstraints();
            
            result = constraintSolver.checkSchedulingFeasibility(updateConstraint, existingMeetings);
            
            if (!result.satisfiable()) {
                log.warn("Z3 Solver: Meeting update is UNSATISFIABLE - {} violations", 
                    result.violations().size());
                return SchedulingResultDTO.failure(
                    result.violations(),
                    "Updated scheduling constraints cannot be satisfied",
                    result.solvingTimeMs()
                );
            }
        } else {
            result = ConstraintResult.success(0);
        }
        
        // Apply updates
        if (meetingDTO.getTitle() != null) {
            meeting.setTitle(meetingDTO.getTitle());
        }
        if (meetingDTO.getDescription() != null) {
            meeting.setDescription(meetingDTO.getDescription());
        }
        meeting.setStartTime(newStartTime);
        meeting.setEndTime(newEndTime);
        meeting.setRoom(room);
        
        if (meetingDTO.getParticipantIds() != null) {
            Set<Participant> participants = participantService.getParticipantEntitiesByIds(newParticipantIds);
            meeting.setParticipants(participants);
        }
        
        meeting = meetingRepository.save(meeting);
        
        meetingMonitor.checkPendingMeetings();
        
        MeetingDTO resultDTO = toDTO(meeting);
        
        log.info("Updated meeting ID: {} (Z3 solving took {}ms)", id, result.solvingTimeMs());
        
        return SchedulingResultDTO.success(
            resultDTO,
            "Meeting updated successfully",
            result.solvingTimeMs()
        );
    }

    @Transactional
    public MeetingDTO updateMeetingStatus(Long id, MeetingStatus newStatus) {
        log.info("Updating meeting {} status to {}", id, newStatus);
        
        Meeting meeting = meetingRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Meeting", id));
        
        MeetingStatus oldStatus = meeting.getStatus();
        
        // Validate status transition
        validateStatusTransition(oldStatus, newStatus);
        
        meeting.setStatus(newStatus);
        meeting = meetingRepository.save(meeting);
        
        switch (newStatus) {
            case CONFIRMED -> meetingMonitor.onMeetingConfirm(id);
            case REJECTED -> meetingMonitor.onMeetingReject(id);
            case CANCELLED -> meetingMonitor.onMeetingCancel(id, oldStatus);
        }
        
        meetingMonitor.checkPendingMeetings();
        
        log.info("Updated meeting {} status from {} to {}", id, oldStatus, newStatus);
        
        return toDTO(meeting);
    }

    @Transactional
    public void deleteMeeting(Long id) {
        log.info("Deleting meeting ID: {}", id);
        
        Meeting meeting = meetingRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Meeting", id));
        
        MeetingStatus previousStatus = meeting.getStatus();
        
        List<PropertyViolation> violations = meetingMonitor.onMeetingDelete(id, previousStatus);
        
        if (!violations.isEmpty()) {
            List<String> violationMessages = violations.stream()
                    .filter(v -> v.severity() == PropertyViolation.ViolationSeverity.ERROR ||
                                 v.severity() == PropertyViolation.ViolationSeverity.CRITICAL)
                    .map(PropertyViolation::description)
                    .collect(Collectors.toList());
            
            if (!violationMessages.isEmpty()) {
                throw new SchedulingException("Delete operation violates runtime properties", violationMessages);
            }
        }
        
        meetingRepository.delete(meeting);
        
        meetingMonitor.removeViolationsForMeeting(id);
        meetingMonitor.checkPendingMeetings();
        
        log.info("Deleted meeting ID: {}", id);
    }

    @Transactional
    public MeetingDTO confirmMeeting(Long id) {
        return updateMeetingStatus(id, MeetingStatus.CONFIRMED);
    }

    @Transactional
    public MeetingDTO rejectMeeting(Long id) {
        return updateMeetingStatus(id, MeetingStatus.REJECTED);
    }

    @Transactional
    public MeetingDTO cancelMeeting(Long id) {
        return updateMeetingStatus(id, MeetingStatus.CANCELLED);
    }

    public Map<String, Object> getVerificationStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("z3SolverInitialized", constraintSolver.isInitialized());
        stats.put("z3SolverEnabled", constraintSolver.isEnabled());
        stats.putAll(meetingMonitor.getStatistics());
        return stats;
    }

    public boolean isZ3SolverEnabled() {
        return constraintSolver.isEnabled();
    }

    public void setZ3SolverEnabled(boolean enabled) {
        constraintSolver.setEnabled(enabled);
    }

    public AvailableSlotsResponseDTO findAvailableSlots(AvailableSlotsRequestDTO request) {
        if (!constraintSolver.isEnabled()) {
            throw new IllegalStateException("Z3 Solver is disabled");
        }

        List<ExistingMeeting> existingMeetings = getExistingMeetingsForConstraints();
        
        long searchStartEpoch = request.getSearchStart().atZone(ZoneId.systemDefault()).toEpochSecond();
        long searchEndEpoch = request.getSearchEnd().atZone(ZoneId.systemDefault()).toEpochSecond();
        
        List<Long> availableSlotEpochs = constraintSolver.findAvailableSlots(
            request.getRoomId(),
            request.getDurationMinutes(),
            searchStartEpoch,
            searchEndEpoch,
            existingMeetings
        );
        
        List<LocalDateTime> availableSlots = availableSlotEpochs.stream()
            .map(epoch -> LocalDateTime.ofInstant(Instant.ofEpochSecond(epoch), ZoneId.systemDefault()))
            .collect(Collectors.toList());
        
        return AvailableSlotsResponseDTO.builder()
            .roomId(request.getRoomId())
            .durationMinutes(request.getDurationMinutes())
            .searchStart(request.getSearchStart())
            .searchEnd(request.getSearchEnd())
            .availableSlots(availableSlots)
            .totalSlots(availableSlots.size())
            .build();
    }

    public SchedulingResultDTO verifyBatchScheduling(List<BatchVerifyRequestDTO> meetings) {
        if (!constraintSolver.isEnabled()) {
            throw new IllegalStateException("Z3 Solver is disabled");
        }

        List<ExistingMeeting> existingMeetings = getExistingMeetingsForConstraints();
        
        List<SchedulingConstraint> constraints = new ArrayList<>();
        
        for (BatchVerifyRequestDTO meetingDTO : meetings) {
            Room room = roomService.getRoomEntityById(meetingDTO.getRoomId());
            
            SchedulingConstraint constraint = new SchedulingConstraint(
                null,
                room.getId(),
                room.getCapacity(),
                meetingDTO.getStartTime(),
                meetingDTO.getEndTime(),
                meetingDTO.getParticipantIds()
            );
            constraints.add(constraint);
        }
        
        ConstraintResult result = constraintSolver.verifyBatchScheduling(constraints, existingMeetings);
        
        if (result.satisfiable()) {
            return SchedulingResultDTO.success(
                null,
                String.format("Batch verification successful: %d meetings can be scheduled", meetings.size()),
                result.solvingTimeMs()
            );
        } else {
            return SchedulingResultDTO.failure(
                result.violations(),
                "Batch scheduling constraints cannot be satisfied",
                result.solvingTimeMs()
            );
        }
    }

    public List<PropertyViolation> getRuntimeViolations() {
        return meetingMonitor.getViolations();
    }

    public List<PropertyViolation> checkPendingMeetingsCompliance() {
        return meetingMonitor.checkPendingMeetings();
    }

    private List<ExistingMeeting> getExistingMeetingsForConstraints() {
        return meetingRepository.findByStatus(MeetingStatus.CONFIRMED).stream()
                .map(m -> new ExistingMeeting(
                    m.getId(),
                    m.getRoom().getId(),
                    m.getStartTime(),
                    m.getEndTime(),
                    m.getParticipants().stream()
                        .map(Participant::getId)
                        .collect(Collectors.toSet())
                ))
                .collect(Collectors.toList());
    }

    private void validateStatusTransition(MeetingStatus from, MeetingStatus to) {
        boolean valid = switch (from) {
            case PENDING -> to == MeetingStatus.CONFIRMED || to == MeetingStatus.REJECTED;
            case CONFIRMED -> to == MeetingStatus.CANCELLED || to == MeetingStatus.COMPLETED;
            case REJECTED, CANCELLED, COMPLETED -> false;
        };
        
        if (!valid) {
            throw new IllegalArgumentException(
                String.format("Invalid status transition from %s to %s", from, to));
        }
    }

    private MeetingDTO toDTO(Meeting meeting) {
        Set<ParticipantDTO> participantDTOs = meeting.getParticipants().stream()
                .map(p -> ParticipantDTO.builder()
                        .id(p.getId())
                        .name(p.getName())
                        .email(p.getEmail())
                        .department(p.getDepartment())
                        .build())
                .collect(Collectors.toSet());
        
        return MeetingDTO.builder()
                .id(meeting.getId())
                .title(meeting.getTitle())
                .description(meeting.getDescription())
                .startTime(meeting.getStartTime())
                .endTime(meeting.getEndTime())
                .roomId(meeting.getRoom().getId())
                .roomName(meeting.getRoom().getName())
                .participantIds(meeting.getParticipants().stream()
                        .map(Participant::getId)
                        .collect(Collectors.toSet()))
                .participants(participantDTOs)
                .status(meeting.getStatus())
                .createdAt(meeting.getCreatedAt())
                .updatedAt(meeting.getUpdatedAt())
                .build();
    }
}
\end{lstlisting}

\subsubsection*{RoomService}
\begin{lstlisting}[
    caption={RoomService.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.scheduler.dto.RoomDTO;
import org.example.scheduler.exception.ResourceNotFoundException;
import org.example.scheduler.model.Room;
import org.example.scheduler.repository.RoomRepository;
import org.example.scheduler.verification.runtime.MeetingMonitor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing meeting rooms.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RoomService {

    private final RoomRepository roomRepository;
    private final MeetingMonitor meetingMonitor;

    /**
     * Creates a new room.
     */
    @Transactional
    public RoomDTO createRoom(RoomDTO roomDTO) {
        log.info("Creating room: {}", roomDTO.getName());
        
        if (roomRepository.existsByName(roomDTO.getName())) {
            throw new IllegalArgumentException("Room with name '" + roomDTO.getName() + "' already exists");
        }
        
        Room room = Room.builder()
                .name(roomDTO.getName())
                .capacity(roomDTO.getCapacity())
                .location(roomDTO.getLocation())
                .description(roomDTO.getDescription())
                .available(roomDTO.getAvailable() != null ? roomDTO.getAvailable() : true)
                .build();
        
        room = roomRepository.save(room);
        
        meetingMonitor.registerRoom(room.getId(), room.getCapacity());
        meetingMonitor.checkPendingMeetings();
        
        log.info("Created room with ID: {}", room.getId());
        return toDTO(room);
    }

    /**
     * Gets a room by ID.
     */
    @Transactional(readOnly = true)
    public RoomDTO getRoomById(Long id) {
        Room room = roomRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Room", id));
        return toDTO(room);
    }

    /**
     * Gets a room entity by ID (for internal use).
     */
    @Transactional(readOnly = true)
    public Room getRoomEntityById(Long id) {
        return roomRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Room", id));
    }

    /**
     * Gets all rooms.
     */
    @Transactional(readOnly = true)
    public List<RoomDTO> getAllRooms() {
        return roomRepository.findAll().stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    /**
     * Gets available rooms.
     */
    @Transactional(readOnly = true)
    public List<RoomDTO> getAvailableRooms() {
        return roomRepository.findByAvailableTrue().stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    /**
     * Gets rooms with minimum capacity.
     */
    @Transactional(readOnly = true)
    public List<RoomDTO> getRoomsWithMinCapacity(int minCapacity) {
        return roomRepository.findAvailableRoomsWithMinCapacity(minCapacity).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    /**
     * Updates a room.
     */
    @Transactional
    public RoomDTO updateRoom(Long id, RoomDTO roomDTO) {
        log.info("Updating room ID: {}", id);
        
        Room room = roomRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Room", id));
        
        if (roomDTO.getName() != null && !roomDTO.getName().equals(room.getName())) {
            if (roomRepository.existsByName(roomDTO.getName())) {
                throw new IllegalArgumentException("Room with name '" + roomDTO.getName() + "' already exists");
            }
            room.setName(roomDTO.getName());
        }
        
        if (roomDTO.getCapacity() != null) {
            room.setCapacity(roomDTO.getCapacity());
            // Update monitor with new capacity
            meetingMonitor.registerRoom(room.getId(), roomDTO.getCapacity());
        }
        
        if (roomDTO.getLocation() != null) {
            room.setLocation(roomDTO.getLocation());
        }
        
        if (roomDTO.getDescription() != null) {
            room.setDescription(roomDTO.getDescription());
        }
        
        if (roomDTO.getAvailable() != null) {
            room.setAvailable(roomDTO.getAvailable());
        }
        
        room = roomRepository.save(room);
        log.info("Updated room ID: {}", id);
        
        return toDTO(room);
    }

    /**
     * Deletes a room.
     */
    @Transactional
    public void deleteRoom(Long id) {
        log.info("Deleting room ID: {}", id);
        
        if (!roomRepository.existsById(id)) {
            throw new ResourceNotFoundException("Room", id);
        }
        
        roomRepository.deleteById(id);
        meetingMonitor.checkPendingMeetings();
        log.info("Deleted room ID: {}", id);
    }

    /**
     * Converts Room entity to DTO.
     */
    private RoomDTO toDTO(Room room) {
        return RoomDTO.builder()
                .id(room.getId())
                .name(room.getName())
                .capacity(room.getCapacity())
                .location(room.getLocation())
                .description(room.getDescription())
                .available(room.getAvailable())
                .build();
    }
}
\end{lstlisting}

\subsubsection*{ParticipantService}
\begin{lstlisting}[
    caption={ParticipantService.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.scheduler.dto.ParticipantDTO;
import org.example.scheduler.exception.ResourceNotFoundException;
import org.example.scheduler.model.Participant;
import org.example.scheduler.repository.ParticipantRepository;
import org.example.scheduler.verification.runtime.MeetingMonitor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ParticipantService {

    private final ParticipantRepository participantRepository;
    private final MeetingMonitor meetingMonitor;

    @Transactional
    public ParticipantDTO createParticipant(ParticipantDTO participantDTO) {
        log.info("Creating participant: {}", participantDTO.getEmail());
        
        if (participantRepository.existsByEmail(participantDTO.getEmail())) {
            throw new IllegalArgumentException("Participant with email '" + participantDTO.getEmail() + "' already exists");
        }
        
        Participant participant = Participant.builder()
                .name(participantDTO.getName())
                .email(participantDTO.getEmail())
                .department(participantDTO.getDepartment())
                .build();
        
        participant = participantRepository.save(participant);
        log.info("Created participant with ID: {}", participant.getId());
        
        meetingMonitor.checkPendingMeetings();
        
        return toDTO(participant);
    }

    @Transactional(readOnly = true)
    public ParticipantDTO getParticipantById(Long id) {
        Participant participant = participantRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Participant", id));
        return toDTO(participant);
    }

    @Transactional(readOnly = true)
    public Set<Participant> getParticipantEntitiesByIds(Set<Long> ids) {
        List<Participant> participants = participantRepository.findByIdIn(ids);
        
        if (participants.size() != ids.size()) {
            Set<Long> foundIds = participants.stream()
                    .map(Participant::getId)
                    .collect(Collectors.toSet());
            Set<Long> missingIds = ids.stream()
                    .filter(id -> !foundIds.contains(id))
                    .collect(Collectors.toSet());
            throw new ResourceNotFoundException("Participants", missingIds);
        }
        
        return new java.util.HashSet<>(participants);
    }

    @Transactional(readOnly = true)
    public List<ParticipantDTO> getAllParticipants() {
        return participantRepository.findAll().stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ParticipantDTO> getParticipantsByDepartment(String department) {
        return participantRepository.findByDepartment(department).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<ParticipantDTO> getBusyParticipants(Set<Long> participantIds, 
            LocalDateTime startTime, LocalDateTime endTime) {
        return participantRepository.findBusyParticipants(participantIds, startTime, endTime).stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
    }

    @Transactional
    public ParticipantDTO updateParticipant(Long id, ParticipantDTO participantDTO) {
        log.info("Updating participant ID: {}", id);
        
        Participant participant = participantRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Participant", id));
        
        if (participantDTO.getName() != null) {
            participant.setName(participantDTO.getName());
        }
        
        if (participantDTO.getEmail() != null && !participantDTO.getEmail().equals(participant.getEmail())) {
            if (participantRepository.existsByEmail(participantDTO.getEmail())) {
                throw new IllegalArgumentException("Participant with email '" + participantDTO.getEmail() + "' already exists");
            }
            participant.setEmail(participantDTO.getEmail());
        }
        
        if (participantDTO.getDepartment() != null) {
            participant.setDepartment(participantDTO.getDepartment());
        }
        
        participant = participantRepository.save(participant);
        log.info("Updated participant ID: {}", id);
        
        return toDTO(participant);
    }

    @Transactional
    public void deleteParticipant(Long id) {
        log.info("Deleting participant ID: {}", id);
        
        if (!participantRepository.existsById(id)) {
            throw new ResourceNotFoundException("Participant", id);
        }
        
        participantRepository.deleteById(id);
        meetingMonitor.checkPendingMeetings();
        log.info("Deleted participant ID: {}", id);
    }

    private ParticipantDTO toDTO(Participant participant) {
        return ParticipantDTO.builder()
                .id(participant.getId())
                .name(participant.getName())
                .email(participant.getEmail())
                .department(participant.getDepartment())
                .build();
    }
}
\end{lstlisting}

\subsubsection*{MeetingRepository}
\begin{lstlisting}[
    caption={MeetingRepository.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.repository;
import org.example.scheduler.model.Meeting;
import org.example.scheduler.model.MeetingStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface MeetingRepository extends JpaRepository<Meeting, Long> {

    List<Meeting> findByStatus(MeetingStatus status);
    List<Meeting> findByRoomId(Long roomId);

    @Query("SELECT m FROM Meeting m WHERE m.room.id = :roomId " +
           "AND m.status IN ('PENDING', 'CONFIRMED') " +
           "AND ((m.startTime < :endTime AND m.endTime > :startTime))")
    List<Meeting> findOverlappingMeetingsInRoom(
        @Param("roomId") Long roomId,
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime
    );

    @Query("SELECT m FROM Meeting m WHERE m.room.id = :roomId " +
           "AND m.status IN ('PENDING', 'CONFIRMED') " +
           "AND m.id != :excludeMeetingId " +
           "AND ((m.startTime < :endTime AND m.endTime > :startTime))")
    List<Meeting> findOverlappingMeetingsInRoomExcluding(
        @Param("roomId") Long roomId,
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime,
        @Param("excludeMeetingId") Long excludeMeetingId
    );

    @Query("SELECT m FROM Meeting m JOIN m.participants p " +
           "WHERE p.id = :participantId " +
           "AND m.status IN ('PENDING', 'CONFIRMED') " +
           "AND ((m.startTime < :endTime AND m.endTime > :startTime))")
    List<Meeting> findOverlappingMeetingsForParticipant(
        @Param("participantId") Long participantId,
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime
    );

    @Query("SELECT m FROM Meeting m WHERE m.startTime >= :start AND m.endTime <= :end " +
           "AND m.status IN ('PENDING', 'CONFIRMED')")
    List<Meeting> findMeetingsInTimeRange(
        @Param("start") LocalDateTime start,
        @Param("end") LocalDateTime end
    );

    @Query("SELECT COUNT(m) FROM Meeting m WHERE m.room.id = :roomId " +
           "AND m.status IN ('PENDING', 'CONFIRMED')")
    long countActiveMeetingsInRoom(@Param("roomId") Long roomId);
}
\end{lstlisting}

\subsubsection*{RoomRepository}
\begin{lstlisting}[
    caption={RoomRepository.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.repository;
import org.example.scheduler.model.Room;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface RoomRepository extends JpaRepository<Room, Long> {

    Optional<Room> findByName(String name);
    List<Room> findByAvailableTrue();
    List<Room> findByCapacityGreaterThanEqual(Integer minCapacity);

    @Query("SELECT r FROM Room r WHERE r.available = true AND r.capacity >= :minCapacity")
    List<Room> findAvailableRoomsWithMinCapacity(@Param("minCapacity") Integer minCapacity);

    boolean existsByName(String name);
}
\end{lstlisting}

\subsubsection*{ParticipantRepository}
\begin{lstlisting}[
    caption={ParticipantRepository.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.repository;
import org.example.scheduler.model.Participant;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;

@Repository
public interface ParticipantRepository extends JpaRepository<Participant, Long> {

    Optional<Participant> findByEmail(String email);
    List<Participant> findByDepartment(String department);
    List<Participant> findByIdIn(Set<Long> ids);
    boolean existsByEmail(String email);

    @Query("SELECT p FROM Participant p JOIN p.meetings m " +
           "WHERE p.id IN :participantIds " +
           "AND m.status IN ('PENDING', 'CONFIRMED') " +
           "AND ((m.startTime < :endTime AND m.endTime > :startTime))")
    List<Participant> findBusyParticipants(
        @Param("participantIds") Set<Long> participantIds,
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime
    );
}
\end{lstlisting}

\subsubsection*{MeetingStatus}
\begin{lstlisting}[
    caption={MeetingStatus.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize, 
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.model;

public enum MeetingStatus {
    PENDING,
    CONFIRMED,
    REJECTED,
    CANCELLED,
    COMPLETED
}
\end{lstlisting}

\subsubsection*{AvailableSlotsRequestDTO}
\begin{lstlisting}[
    caption={AvailableSlotsRequestDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AvailableSlotsRequestDTO {
    
    @NotNull(message = "Room ID is required")
    private Long roomId;
    
    @NotNull(message = "Duration in minutes is required")
    @Positive(message = "Duration must be positive")
    private Integer durationMinutes;
    
    @NotNull(message = "Search start time is required")
    private LocalDateTime searchStart;
    
    @NotNull(message = "Search end time is required")
    private LocalDateTime searchEnd;
}
\end{lstlisting}

\subsubsection*{AvailableSlotsResponseDTO}
\begin{lstlisting}[
    caption={AvailableSlotsResponseDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AvailableSlotsResponseDTO {
    private Long roomId;
    private Integer durationMinutes;
    private LocalDateTime searchStart;
    private LocalDateTime searchEnd;
    private List<LocalDateTime> availableSlots;
    private Integer totalSlots;
}
\end{lstlisting}

\subsubsection*{BatchVerifyRequestDTO}
\begin{lstlisting}[
    caption={BatchVerifyRequestDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BatchVerifyRequestDTO {
    
    @NotBlank(message = "Meeting title is required")
    private String title;

    private String description;

    @NotNull(message = "Start time is required")
    private LocalDateTime startTime;

    @NotNull(message = "End time is required")
    private LocalDateTime endTime;

    @NotNull(message = "Room ID is required")
    private Long roomId;

    @NotEmpty(message = "At least one participant is required")
    private Set<Long> participantIds;
}
\end{lstlisting}

\subsubsection*{MeetingDTO}
\begin{lstlisting}[
    caption={MeetingDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.example.scheduler.model.MeetingStatus;
import java.time.LocalDateTime;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MeetingDTO {
    
    private Long id;

    @NotBlank(message = "Meeting title is required")
    private String title;

    private String description;

    @NotNull(message = "Start time is required")
    private LocalDateTime startTime;

    @NotNull(message = "End time is required")
    private LocalDateTime endTime;

    @NotNull(message = "Room ID is required")
    private Long roomId;

    private String roomName;

    @NotEmpty(message = "At least one participant is required")
    private Set<Long> participantIds;

    private Set<ParticipantDTO> participants;

    private MeetingStatus status;

    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;
}

\end{lstlisting}

\subsubsection*{RoomDTO}
\begin{lstlisting}[
    caption={RoomDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomDTO {
    
    private Long id;

    @NotBlank(message = "Room name is required")
    private String name;

    @NotNull(message = "Capacity is required")
    @Min(value = 1, message = "Capacity must be at least 1")
    private Integer capacity;

    private String location;

    private String description;

    private Boolean available;
}
\end{lstlisting}

\subsubsection*{ParticipantDTO}
\begin{lstlisting}[
    caption={ParticipantDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ParticipantDTO {
    
    private Long id;

    @NotBlank(message = "Participant name is required")
    private String name;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    private String department;
}

\end{lstlisting}

\subsubsection*{SchedulingResultDTO}
\begin{lstlisting}[
    caption={SchedulingResultDTO.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.dto;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SchedulingResultDTO {
    
    private boolean success;

    private MeetingDTO meeting;

    @Builder.Default
    private List<String> constraintViolations = new ArrayList<>();

    @Builder.Default
    private List<String> runtimeWarnings = new ArrayList<>();

    private String solverStatus;

    private String explanation;

    private Long solvingTimeMs;

    public static SchedulingResultDTO success(MeetingDTO meeting, String explanation, Long solvingTimeMs) {
        return SchedulingResultDTO.builder()
                .success(true)
                .meeting(meeting)
                .solverStatus("SATISFIABLE")
                .explanation(explanation)
                .solvingTimeMs(solvingTimeMs)
                .build();
    }

    public static SchedulingResultDTO failure(List<String> violations, String explanation, Long solvingTimeMs) {
        return SchedulingResultDTO.builder()
                .success(false)
                .constraintViolations(violations)
                .solverStatus("UNSATISFIABLE")
                .explanation(explanation)
                .solvingTimeMs(solvingTimeMs)
                .build();
    }
}
\end{lstlisting}

\subsubsection*{MeetingController}
\begin{lstlisting}[
    caption={MeetingController.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.controller;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.example.scheduler.dto.AvailableSlotsRequestDTO;
import org.example.scheduler.dto.AvailableSlotsResponseDTO;
import org.example.scheduler.dto.BatchVerifyRequestDTO;
import org.example.scheduler.dto.MeetingDTO;
import org.example.scheduler.dto.SchedulingResultDTO;
import org.example.scheduler.model.MeetingStatus;
import org.example.scheduler.service.MeetingService;
import org.example.scheduler.verification.runtime.PropertyViolation;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/meetings")
@RequiredArgsConstructor
public class MeetingController {

    private final MeetingService meetingService;

    @PostMapping
    public ResponseEntity<SchedulingResultDTO> createMeeting(@Valid @RequestBody MeetingDTO meetingDTO) {
        SchedulingResultDTO result = meetingService.createMeeting(meetingDTO);
        
        if (result.isSuccess()) {
            return ResponseEntity.status(HttpStatus.CREATED).body(result);
        } else {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(result);
        }
    }

    @GetMapping("/{id}")
    public ResponseEntity<MeetingDTO> getMeetingById(@PathVariable Long id) {
        MeetingDTO meeting = meetingService.getMeetingById(id);
        return ResponseEntity.ok(meeting);
    }

    @GetMapping
    public ResponseEntity<List<MeetingDTO>> getAllMeetings() {
        List<MeetingDTO> meetings = meetingService.getAllMeetings();
        return ResponseEntity.ok(meetings);
    }

    @GetMapping("/status/{status}")
    public ResponseEntity<List<MeetingDTO>> getMeetingsByStatus(@PathVariable MeetingStatus status) {
        List<MeetingDTO> meetings = meetingService.getMeetingsByStatus(status);
        return ResponseEntity.ok(meetings);
    }

    @GetMapping("/room/{roomId}")
    public ResponseEntity<List<MeetingDTO>> getMeetingsByRoom(@PathVariable Long roomId) {
        List<MeetingDTO> meetings = meetingService.getMeetingsByRoom(roomId);
        return ResponseEntity.ok(meetings);
    }

    @GetMapping("/range")
    public ResponseEntity<List<MeetingDTO>> getMeetingsInTimeRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end) {
        List<MeetingDTO> meetings = meetingService.getMeetingsInTimeRange(start, end);
        return ResponseEntity.ok(meetings);
    }

    @PutMapping("/{id}")
    public ResponseEntity<SchedulingResultDTO> updateMeeting(
            @PathVariable Long id, 
            @RequestBody MeetingDTO meetingDTO) {
        SchedulingResultDTO result = meetingService.updateMeeting(id, meetingDTO);
        
        if (result.isSuccess()) {
            return ResponseEntity.ok(result);
        } else {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(result);
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteMeeting(@PathVariable Long id) {
        meetingService.deleteMeeting(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/confirm")
    public ResponseEntity<MeetingDTO> confirmMeeting(@PathVariable Long id) {
        MeetingDTO meeting = meetingService.confirmMeeting(id);
        return ResponseEntity.ok(meeting);
    }

    @PostMapping("/{id}/reject")
    public ResponseEntity<MeetingDTO> rejectMeeting(@PathVariable Long id) {
        MeetingDTO meeting = meetingService.rejectMeeting(id);
        return ResponseEntity.ok(meeting);
    }

    @PostMapping("/{id}/cancel")
    public ResponseEntity<MeetingDTO> cancelMeeting(@PathVariable Long id) {
        MeetingDTO meeting = meetingService.cancelMeeting(id);
        return ResponseEntity.ok(meeting);
    }

    @GetMapping("/verification/stats")
    public ResponseEntity<Map<String, Object>> getVerificationStatistics() {
        Map<String, Object> stats = meetingService.getVerificationStatistics();
        return ResponseEntity.ok(stats);
    }

    @GetMapping("/verification/violations")
    public ResponseEntity<List<PropertyViolation>> getRuntimeViolations() {
        List<PropertyViolation> violations = meetingService.getRuntimeViolations();
        return ResponseEntity.ok(violations);
    }

    @PostMapping("/verification/check-pending")
    public ResponseEntity<List<PropertyViolation>> checkPendingMeetings() {
        List<PropertyViolation> violations = meetingService.checkPendingMeetingsCompliance();
        return ResponseEntity.ok(violations);
    }

    @GetMapping("/verification/z3-enabled")
    public ResponseEntity<Map<String, Boolean>> getZ3SolverStatus() {
        Map<String, Boolean> status = new java.util.HashMap<>();
        status.put("enabled", meetingService.isZ3SolverEnabled());
        return ResponseEntity.ok(status);
    }

    @PostMapping("/verification/z3-enabled")
    public ResponseEntity<Map<String, Boolean>> setZ3SolverEnabled(@RequestBody Map<String, Boolean> request) {
        Boolean enabled = request.get("enabled");
        if (enabled == null) {
            return ResponseEntity.badRequest().build();
        }
        meetingService.setZ3SolverEnabled(enabled);
        Map<String, Boolean> status = new java.util.HashMap<>();
        status.put("enabled", meetingService.isZ3SolverEnabled());
        return ResponseEntity.ok(status);
    }

    @PostMapping("/available-slots")
    public ResponseEntity<AvailableSlotsResponseDTO> findAvailableSlots(
            @Valid @RequestBody AvailableSlotsRequestDTO request) {
        AvailableSlotsResponseDTO response = meetingService.findAvailableSlots(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/batch-verify")
    public ResponseEntity<SchedulingResultDTO> verifyBatchScheduling(
            @Valid @RequestBody List<BatchVerifyRequestDTO> meetings) {
        SchedulingResultDTO result = meetingService.verifyBatchScheduling(meetings);
        return ResponseEntity.ok(result);
    }
}
\end{lstlisting}

\subsubsection*{RoomController}
\begin{lstlisting}[
    caption={RoomController.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.controller;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.example.scheduler.dto.RoomDTO;
import org.example.scheduler.service.RoomService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/rooms")
@RequiredArgsConstructor
public class RoomController {

    private final RoomService roomService;

    @PostMapping
    public ResponseEntity<RoomDTO> createRoom(@Valid @RequestBody RoomDTO roomDTO) {
        RoomDTO created = roomService.createRoom(roomDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    @GetMapping("/{id}")
    public ResponseEntity<RoomDTO> getRoomById(@PathVariable Long id) {
        RoomDTO room = roomService.getRoomById(id);
        return ResponseEntity.ok(room);
    }

    @GetMapping
    public ResponseEntity<List<RoomDTO>> getAllRooms() {
        List<RoomDTO> rooms = roomService.getAllRooms();
        return ResponseEntity.ok(rooms);
    }

    @GetMapping("/available")
    public ResponseEntity<List<RoomDTO>> getAvailableRooms() {
        List<RoomDTO> rooms = roomService.getAvailableRooms();
        return ResponseEntity.ok(rooms);
    }

    @GetMapping("/capacity/{minCapacity}")
    public ResponseEntity<List<RoomDTO>> getRoomsWithMinCapacity(@PathVariable int minCapacity) {
        List<RoomDTO> rooms = roomService.getRoomsWithMinCapacity(minCapacity);
        return ResponseEntity.ok(rooms);
    }

    @PutMapping("/{id}")
    public ResponseEntity<RoomDTO> updateRoom(@PathVariable Long id, @RequestBody RoomDTO roomDTO) {
        RoomDTO updated = roomService.updateRoom(id, roomDTO);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteRoom(@PathVariable Long id) {
        roomService.deleteRoom(id);
        return ResponseEntity.noContent().build();
    }
}
\end{lstlisting}

\subsubsection*{ParticipantController}
\begin{lstlisting}[
    caption={ParticipantController.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.controller;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.example.scheduler.dto.ParticipantDTO;
import org.example.scheduler.service.ParticipantService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/participants")
@RequiredArgsConstructor
public class ParticipantController {

    private final ParticipantService participantService;

    @PostMapping
    public ResponseEntity<ParticipantDTO> createParticipant(@Valid @RequestBody ParticipantDTO participantDTO) {
        ParticipantDTO created = participantService.createParticipant(participantDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ParticipantDTO> getParticipantById(@PathVariable Long id) {
        ParticipantDTO participant = participantService.getParticipantById(id);
        return ResponseEntity.ok(participant);
    }

    @GetMapping
    public ResponseEntity<List<ParticipantDTO>> getAllParticipants() {
        List<ParticipantDTO> participants = participantService.getAllParticipants();
        return ResponseEntity.ok(participants);
    }

    @GetMapping("/department/{department}")
    public ResponseEntity<List<ParticipantDTO>> getParticipantsByDepartment(@PathVariable String department) {
        List<ParticipantDTO> participants = participantService.getParticipantsByDepartment(department);
        return ResponseEntity.ok(participants);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ParticipantDTO> updateParticipant(
            @PathVariable Long id, 
            @RequestBody ParticipantDTO participantDTO) {
        ParticipantDTO updated = participantService.updateParticipant(id, participantDTO);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteParticipant(@PathVariable Long id) {
        participantService.deleteParticipant(id);
        return ResponseEntity.noContent().build();
    }
}
\end{lstlisting}

\subsubsection{Runtime Verification Classes}
\subsubsection*{MeetingMonitor}
\begin{lstlisting}[
    caption={MeetingMonitor.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.runtime;
import lombok.extern.slf4j.Slf4j;
import org.example.scheduler.model.Meeting;
import org.example.scheduler.model.MeetingStatus;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Runtime Verification Monitor for meeting scheduling.
 * 
 * Monitors:
 * 
 * 1 - Create Flow: G (create(id) → F (confirm(id) ∨ reject(id)))
 *   Every created meeting must eventually be confirmed or rejected.
 * 
 * 2 - Delete Safety: G (delete(id) → previouslyCreated(id))
 *   Cannot delete a meeting that doesn't exist.
 * 
 * 3 - No Overlaps: G ¬overlaps(meetingA, meetingB)
 *   No two meetings can overlap in the same room.
 * 
 * 4 - Capacity: G (assign(room, attendees) → attendees ≤ capacity(room))
 *   Room capacity must not be exceeded.
 */
@Component
@Slf4j
public class MeetingMonitor {

    private final Map<Long, MeetingEvent> pendingMeetings = new ConcurrentHashMap<>();
    private final Set<Long> createdMeetings = ConcurrentHashMap.newKeySet();
    private final Map<Long, List<ActiveMeetingSlot>> roomSchedule = new ConcurrentHashMap<>();
    private final List<MeetingEvent> eventHistory = Collections.synchronizedList(new ArrayList<>());
    private final List<PropertyViolation> violations = Collections.synchronizedList(new ArrayList<>());
    private final Map<Long, Integer> roomCapacities = new ConcurrentHashMap<>();

    private record ActiveMeetingSlot(
        Long meetingId,
        LocalDateTime startTime,
        LocalDateTime endTime
    ) {}

    public void registerRoom(Long roomId, int capacity) {
        roomCapacities.put(roomId, capacity);
        roomSchedule.putIfAbsent(roomId, Collections.synchronizedList(new ArrayList<>()));
        log.debug("RV Monitor: Registered room {} with capacity {}", roomId, capacity);
    }

    public List<PropertyViolation> onMeetingCreate(Meeting meeting) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        MeetingEvent event = MeetingEvent.create(
            meeting.getId(),
            meeting.getRoom().getId(),
            meeting.getStartTime(),
            meeting.getEndTime(),
            meeting.getParticipants().size()
        );
        
        eventHistory.add(event);
        createdMeetings.add(meeting.getId());
        pendingMeetings.put(meeting.getId(), event);
        
        Integer roomCapacity = roomCapacities.get(meeting.getRoom().getId());
        if (roomCapacity != null && meeting.getParticipants().size() > roomCapacity) {
            PropertyViolation violation = PropertyViolation.error(
                "CAPACITY_EXCEEDED",
                "Room capacity exceeded",
                meeting.getId(),
                String.format("Meeting has %d participants but room capacity is %d",
                    meeting.getParticipants().size(), roomCapacity)
            );
            if (!isDuplicateViolation(violation)) {
                newViolations.add(violation);
                violations.add(violation);
            }
        }
        
        List<PropertyViolation> overlapViolations = checkOverlaps(meeting);
        for (PropertyViolation violation : overlapViolations) {
            if (!isDuplicateViolation(violation)) {
                newViolations.add(violation);
                violations.add(violation);
            }
        }
       
        if (overlapViolations.isEmpty()) {
            roomSchedule.computeIfAbsent(meeting.getRoom().getId(), 
                k -> Collections.synchronizedList(new ArrayList<>()))
                .add(new ActiveMeetingSlot(meeting.getId(), meeting.getStartTime(), meeting.getEndTime()));
        }
        
        log.info("RV Monitor: CREATE event for meeting {} - {} violations detected", 
            meeting.getId(), newViolations.size());
        
        return newViolations;
    }

    public List<PropertyViolation> onMeetingConfirm(Long meetingId) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        MeetingEvent event = MeetingEvent.confirm(meetingId);
        eventHistory.add(event);
        
        MeetingEvent pending = pendingMeetings.remove(meetingId);
        if (pending == null) {
            PropertyViolation violation = PropertyViolation.warning(
                "CONFIRM_WITHOUT_CREATE",
                "Confirming a meeting that was not tracked as pending",
                meetingId,
                "Meeting may have been created before monitor was active"
            );
            if (!isDuplicateViolation(violation)) {
                newViolations.add(violation);
                violations.add(violation);
            }
        }
        
        violations.removeIf(v -> 
            "UNRESOLVED_MEETING".equals(v.propertyName()) && 
            meetingId.equals(v.meetingId())
        );
        
        log.info("RV Monitor: CONFIRM event for meeting {}", meetingId);
        return newViolations;
    }

    public List<PropertyViolation> onMeetingReject(Long meetingId) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        MeetingEvent event = MeetingEvent.reject(meetingId);
        eventHistory.add(event);
        
        pendingMeetings.remove(meetingId);
        
        violations.removeIf(v -> 
            "UNRESOLVED_MEETING".equals(v.propertyName()) && 
            meetingId.equals(v.meetingId())
        );
        
        for (List<ActiveMeetingSlot> slots : roomSchedule.values()) {
            slots.removeIf(slot -> slot.meetingId().equals(meetingId));
        }
        
        log.info("RV Monitor: REJECT event for meeting {}", meetingId);
        return newViolations;
    }

    public List<PropertyViolation> onMeetingDelete(Long meetingId, MeetingStatus previousStatus) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        MeetingEvent event = MeetingEvent.delete(meetingId, previousStatus);
        eventHistory.add(event);
        
        if (!createdMeetings.contains(meetingId)) {
            PropertyViolation violation = PropertyViolation.error(
                "DELETE_NONEXISTENT",
                "Attempting to delete a meeting that doesn't exist",
                meetingId,
                "Property G(delete(id) → previouslyCreated(id)) violated"
            );
            if (!isDuplicateViolation(violation)) {
                newViolations.add(violation);
                violations.add(violation);
            }
        }
        
        createdMeetings.remove(meetingId);
        pendingMeetings.remove(meetingId);
        
        for (List<ActiveMeetingSlot> slots : roomSchedule.values()) {
            slots.removeIf(slot -> slot.meetingId().equals(meetingId));
        }
        
        log.info("RV Monitor: DELETE event for meeting {} - {} violations detected", 
            meetingId, newViolations.size());
        
        return newViolations;
    }

    public List<PropertyViolation> onMeetingCancel(Long meetingId, MeetingStatus previousStatus) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        MeetingEvent event = MeetingEvent.cancel(meetingId, previousStatus);
        eventHistory.add(event);
        
        pendingMeetings.remove(meetingId);
        
        for (List<ActiveMeetingSlot> slots : roomSchedule.values()) {
            slots.removeIf(slot -> slot.meetingId().equals(meetingId));
        }
        
        log.info("RV Monitor: CANCEL event for meeting {}", meetingId);
        return newViolations;
    }

    private List<PropertyViolation> checkOverlaps(Meeting newMeeting) {
        List<PropertyViolation> newViolations = new ArrayList<>();
        
        Long roomId = newMeeting.getRoom().getId();
        List<ActiveMeetingSlot> slots = roomSchedule.get(roomId);
        
        if (slots != null) {
            for (ActiveMeetingSlot existing : slots) {
                if (existing.meetingId().equals(newMeeting.getId())) {
                    continue;
                }
                
                // Check for overlap: start1 < end2 AND start2 < end1
                if (newMeeting.getStartTime().isBefore(existing.endTime()) &&
                    existing.startTime().isBefore(newMeeting.getEndTime())) {
                    
                    PropertyViolation violation = PropertyViolation.critical(
                        "MEETING_OVERLAP",
                        "Overlapping meetings detected in same room",
                        newMeeting.getId(),
                        String.format("Meeting %d overlaps with meeting %d in room %d",
                            newMeeting.getId(), existing.meetingId(), roomId)
                    );
                    newViolations.add(violation);
                }
            }
        }
        
        return newViolations;
    }

    public List<PropertyViolation> checkPendingMeetings() {
        List<PropertyViolation> newViolations = new ArrayList<>();
        LocalDateTime now = LocalDateTime.now();
        
        for (Map.Entry<Long, MeetingEvent> entry : pendingMeetings.entrySet()) {
            MeetingEvent event = entry.getValue();
            
            if (event.startTime() != null && event.startTime().isBefore(now)) {
                PropertyViolation violation = PropertyViolation.error(
                    "UNRESOLVED_MEETING",
                    "Meeting started without being confirmed or rejected",
                    entry.getKey(),
                    String.format("Property G(create(id) → F(confirm(id) ∨ reject(id))) violated. " +
                        "Meeting created at %s, start time was %s",
                        event.eventTimestamp(), event.startTime())
                );
                if (!isDuplicateViolation(violation)) {
                    newViolations.add(violation);
                    violations.add(violation);
                }
            }
        }
        
        return newViolations;
    }

    public List<PropertyViolation> getViolations() {
        return new ArrayList<>(violations);
    }

    public List<PropertyViolation> getViolationsBySeverity(PropertyViolation.ViolationSeverity severity) {
        return violations.stream()
            .filter(v -> v.severity() == severity)
            .toList();
    }

    public List<MeetingEvent> getEventHistory() {
        return new ArrayList<>(eventHistory);
    }

    public int getPendingMeetingsCount() {
        return pendingMeetings.size();
    }

    public void reset() {
        pendingMeetings.clear();
        createdMeetings.clear();
        roomSchedule.clear();
        eventHistory.clear();
        violations.clear();
        log.info("RV Monitor: State reset");
    }

    private boolean isDuplicateViolation(PropertyViolation violation) {
        return violations.stream().anyMatch(existing ->
            existing.propertyName().equals(violation.propertyName()) &&
            Objects.equals(existing.meetingId(), violation.meetingId()) &&
            existing.description().equals(violation.description()) &&
            existing.details().equals(violation.details())
        );
    }

    public void removeViolationsForMeeting(Long meetingId) {
        violations.removeIf(v -> meetingId.equals(v.meetingId()));
        log.info("RV Monitor: Removed violations for meeting {}", meetingId);
    }

    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("totalEvents", eventHistory.size());
        stats.put("pendingMeetings", pendingMeetings.size());
        stats.put("trackedMeetings", createdMeetings.size());
        stats.put("totalViolations", violations.size());
        stats.put("criticalViolations", 
            getViolationsBySeverity(PropertyViolation.ViolationSeverity.CRITICAL).size());
        stats.put("errorViolations", 
            getViolationsBySeverity(PropertyViolation.ViolationSeverity.ERROR).size());
        stats.put("warningViolations", 
            getViolationsBySeverity(PropertyViolation.ViolationSeverity.WARNING).size());
        return stats;
    }
}
\end{lstlisting}

\subsubsection*{MeetingMonitorAspect}
\begin{lstlisting}[
    caption={MeetingMonitorAspect.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.runtime;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.example.scheduler.dto.MeetingDTO;
import org.example.scheduler.dto.SchedulingResultDTO;
import org.example.scheduler.model.Meeting;
import org.example.scheduler.model.MeetingStatus;
import org.springframework.stereotype.Component;

import java.util.List;

@Aspect
@Component
@RequiredArgsConstructor
@Slf4j
public class MeetingMonitorAspect {

    private final MeetingMonitor meetingMonitor;

    @Pointcut("execution(* org.example.scheduler.service.MeetingService.createMeeting(..))")
    public void meetingCreation() {}

    @Pointcut("execution(* org.example.scheduler.service.MeetingService.updateMeeting(..))")
    public void meetingUpdate() {}

    @Pointcut("execution(* org.example.scheduler.service.MeetingService.deleteMeeting(..))")
    public void meetingDeletion() {}

    @Pointcut("execution(* org.example.scheduler.service.MeetingService.updateMeetingStatus(..))")
    public void meetingStatusChange() {}

    @AfterReturning(pointcut = "meetingCreation()", returning = "result")
    public void afterMeetingCreation(JoinPoint joinPoint, Object result) {
        if (result instanceof SchedulingResultDTO dto && dto.isSuccess() && dto.getMeeting() != null) {
            log.debug("RV Aspect: Intercepted successful meeting creation for ID {}", 
                dto.getMeeting().getId());
        }
    }

    @Before("meetingDeletion() && args(meetingId)")
    public void beforeMeetingDeletion(JoinPoint joinPoint, Long meetingId) {
        log.debug("RV Aspect: Intercepted meeting deletion request for ID {}", meetingId);
    }

    @AfterReturning(pointcut = "meetingStatusChange() && args(meetingId, newStatus)", returning = "result")
    public void afterStatusChange(JoinPoint joinPoint, Long meetingId, MeetingStatus newStatus, Object result) {
        log.debug("RV Aspect: Intercepted status change for meeting {} to {}", meetingId, newStatus);
        
        switch (newStatus) {
            case CONFIRMED -> meetingMonitor.onMeetingConfirm(meetingId);
            case REJECTED -> meetingMonitor.onMeetingReject(meetingId);
            case CANCELLED -> meetingMonitor.onMeetingCancel(meetingId, MeetingStatus.CONFIRMED);
            default -> log.debug("RV Aspect: No specific handling for status {}", newStatus);
        }
    }

    @AfterThrowing(pointcut = "meetingCreation() || meetingUpdate() || meetingDeletion()", 
                   throwing = "exception")
    public void afterMeetingOperationException(JoinPoint joinPoint, Exception exception) {
        log.warn("RV Aspect: Meeting operation failed - {}: {}", 
            joinPoint.getSignature().getName(), exception.getMessage());
    }
}
\end{lstlisting}

\subsubsection*{MeetingEvent}
\begin{lstlisting}[
    caption={MeetingEvent.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.runtime;
import org.example.scheduler.model.MeetingStatus;
import java.time.LocalDateTime;

public record MeetingEvent(
    EventType eventType,
    Long meetingId,
    Long roomId,
    LocalDateTime startTime,
    LocalDateTime endTime,
    int participantCount,
    MeetingStatus previousStatus,
    MeetingStatus newStatus,
    LocalDateTime eventTimestamp
) {
    public enum EventType {
        CREATE,
        UPDATE,
        DELETE,
        CONFIRM,
        REJECT,
        CANCEL,
        COMPLETE
    }

    public static MeetingEvent create(Long meetingId, Long roomId, 
            LocalDateTime startTime, LocalDateTime endTime, int participantCount) {
        return new MeetingEvent(
            EventType.CREATE, meetingId, roomId, startTime, endTime, 
            participantCount, null, MeetingStatus.PENDING, LocalDateTime.now()
        );
    }

    public static MeetingEvent confirm(Long meetingId) {
        return new MeetingEvent(
            EventType.CONFIRM, meetingId, null, null, null, 
            0, MeetingStatus.PENDING, MeetingStatus.CONFIRMED, LocalDateTime.now()
        );
    }

    public static MeetingEvent reject(Long meetingId) {
        return new MeetingEvent(
            EventType.REJECT, meetingId, null, null, null, 
            0, MeetingStatus.PENDING, MeetingStatus.REJECTED, LocalDateTime.now()
        );
    }

    public static MeetingEvent delete(Long meetingId, MeetingStatus previousStatus) {
        return new MeetingEvent(
            EventType.DELETE, meetingId, null, null, null, 
            0, previousStatus, null, LocalDateTime.now()
        );
    }

    public static MeetingEvent cancel(Long meetingId, MeetingStatus previousStatus) {
        return new MeetingEvent(
            EventType.CANCEL, meetingId, null, null, null, 
            0, previousStatus, MeetingStatus.CANCELLED, LocalDateTime.now()
        );
    }
}
\end{lstlisting}

\subsubsection*{PropertyViolation}
\begin{lstlisting}[
    caption={PropertyViolation.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.verification.runtime;
import java.time.LocalDateTime;

public record PropertyViolation(
    String propertyName,
    String description,
    ViolationSeverity severity,
    Long meetingId,
    LocalDateTime detectedAt,
    String details
) {
    public enum ViolationSeverity {
        WARNING,    // Potential issue that should be investigated
        ERROR,      // Constraint violation that blocks the operation
        CRITICAL    // System invariant violation
    }

    public static PropertyViolation error(String propertyName, String description, 
            Long meetingId, String details) {
        return new PropertyViolation(
            propertyName, description, ViolationSeverity.ERROR, 
            meetingId, LocalDateTime.now(), details
        );
    }

    public static PropertyViolation warning(String propertyName, String description, 
            Long meetingId, String details) {
        return new PropertyViolation(
            propertyName, description, ViolationSeverity.WARNING, 
            meetingId, LocalDateTime.now(), details
        );
    }

    public static PropertyViolation critical(String propertyName, String description, 
            Long meetingId, String details) {
        return new PropertyViolation(
            propertyName, description, ViolationSeverity.CRITICAL, 
            meetingId, LocalDateTime.now(), details
        );
    }
}
\end{lstlisting}

\subsubsection{Custom Exception Classes}

\subsubsection*{GlobalExceptionHandler}
\begin{lstlisting}[
    caption={GlobalExceptionHandler.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.exception;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleResourceNotFound(ResourceNotFoundException ex) {
        log.error("Resource not found: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.NOT_FOUND.value());
        response.put("error", "Not Found");
        response.put("message", ex.getMessage());
        response.put("resourceType", ex.getResourceType());
        response.put("resourceId", ex.getResourceId());
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    @ExceptionHandler(SchedulingException.class)
    public ResponseEntity<Map<String, Object>> handleSchedulingException(SchedulingException ex) {
        log.error("Scheduling constraint violation: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.CONFLICT.value());
        response.put("error", "Scheduling Conflict");
        response.put("message", ex.getMessage());
        response.put("violations", ex.getViolations());
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.BAD_REQUEST.value());
        response.put("error", "Validation Error");
        
        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });
        response.put("fieldErrors", fieldErrors);
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, Object>> handleIllegalArgument(IllegalArgumentException ex) {
        log.error("Invalid argument: {}", ex.getMessage());
        
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.BAD_REQUEST.value());
        response.put("error", "Bad Request");
        response.put("message", ex.getMessage());
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGenericException(Exception ex) {
        log.error("Unexpected error", ex);
        
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        response.put("error", "Internal Server Error");
        response.put("message", "An unexpected error occurred");
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
\end{lstlisting}

\subsubsection*{ResourceNotFoundException}
\begin{lstlisting}[
    caption={ResourceNotFoundException.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.exception;

public class ResourceNotFoundException extends RuntimeException {
    
    private final String resourceType;
    private final Object resourceId;

    public ResourceNotFoundException(String resourceType, Object resourceId) {
        super(String.format("%s not found with id: %s", resourceType, resourceId));
        this.resourceType = resourceType;
        this.resourceId = resourceId;
    }

    public String getResourceType() {
        return resourceType;
    }

    public Object getResourceId() {
        return resourceId;
    }
}
\end{lstlisting}

\subsubsection*{SchedulingException}
\begin{lstlisting}[
    caption={SchedulingException.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.exception;
import java.util.ArrayList;
import java.util.List;

public class SchedulingException extends RuntimeException {
    
    private final List<String> violations;

    public SchedulingException(String message) {
        super(message);
        this.violations = new ArrayList<>();
    }

    public SchedulingException(String message, List<String> violations) {
        super(message);
        this.violations = violations != null ? violations : new ArrayList<>();
    }

    public List<String> getViolations() {
        return violations;
    }
}
\end{lstlisting}

\subsubsection{Configuration Classes}

\subsubsection*{CorsConfig}
\begin{lstlisting}[
    caption={CorsConfig.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import java.util.Arrays;

@Configuration
public class CorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.setAllowedOrigins(Arrays.asList("http://localhost:3000", "http://127.0.0.1:3000"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        
        return new CorsFilter(source);
    }
}
\end{lstlisting}

\subsubsection*{DataInitializer}
\begin{lstlisting}[
    caption={DataInitializer.java},
    language=Java,
    basicstyle=\ttfamily\footnotesize,  % Smaller font for more content
    frame=single,
    numbers=left,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}  % Visible line break indicator
]
package org.example.scheduler.config;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.scheduler.model.Participant;
import org.example.scheduler.model.Room;
import org.example.scheduler.repository.ParticipantRepository;
import org.example.scheduler.repository.RoomRepository;
import org.example.scheduler.verification.runtime.MeetingMonitor;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
@Profile("!test")
@RequiredArgsConstructor
@Slf4j
public class DataInitializer implements CommandLineRunner {

    private final RoomRepository roomRepository;
    private final ParticipantRepository participantRepository;
    private final MeetingMonitor meetingMonitor;

    @Override
    public void run(String... args) {
        log.info("Initializing sample data...");
        
        initializeRooms();
        initializeParticipants();
        
        log.info("Sample data initialization complete!");
    }

    private void initializeRooms() {
        if (roomRepository.count() > 0) {
            log.info("Rooms already exist, skipping initialization");
            return;
        }

        List<Room> rooms = List.of(
            Room.builder()
                .name("Conference Room A")
                .capacity(10)
                .location("Building 1, Floor 2")
                .description("Large conference room with projector and whiteboard")
                .available(true)
                .build(),
            Room.builder()
                .name("Meeting Room B")
                .capacity(6)
                .location("Building 1, Floor 1")
                .description("Medium-sized meeting room with video conferencing")
                .available(true)
                .build(),
            Room.builder()
                .name("Huddle Space C")
                .capacity(4)
                .location("Building 2, Floor 1")
                .description("Small huddle room for quick meetings")
                .available(true)
                .build(),
            Room.builder()
                .name("Board Room")
                .capacity(20)
                .location("Building 1, Floor 3")
                .description("Executive board room with premium AV equipment")
                .available(true)
                .build(),
            Room.builder()
                .name("Training Room")
                .capacity(30)
                .location("Building 2, Floor 2")
                .description("Large training room with classroom setup")
                .available(true)
                .build()
        );

        roomRepository.saveAll(rooms);
        
        rooms.forEach(room -> {
            Room savedRoom = roomRepository.findByName(room.getName()).orElse(room);
            meetingMonitor.registerRoom(savedRoom.getId(), savedRoom.getCapacity());
        });
        
        log.info("Created {} sample rooms", rooms.size());
    }

    private void initializeParticipants() {
        if (participantRepository.count() > 0) {
            log.info("Participants already exist, skipping initialization");
            return;
        }

        List<Participant> participants = List.of(
            Participant.builder()
                .name("Alice Johnson")
                .email("alice.johnson@company.com")
                .department("Engineering")
                .build(),
            Participant.builder()
                .name("Bob Smith")
                .email("bob.smith@company.com")
                .department("Engineering")
                .build(),
            Participant.builder()
                .name("Carol Williams")
                .email("carol.williams@company.com")
                .department("Product")
                .build(),
            Participant.builder()
                .name("David Brown")
                .email("david.brown@company.com")
                .department("Design")
                .build(),
            Participant.builder()
                .name("Eva Martinez")
                .email("eva.martinez@company.com")
                .department("Marketing")
                .build(),
            Participant.builder()
                .name("Frank Lee")
                .email("frank.lee@company.com")
                .department("Engineering")
                .build(),
            Participant.builder()
                .name("Grace Chen")
                .email("grace.chen@company.com")
                .department("HR")
                .build(),
            Participant.builder()
                .name("Henry Wilson")
                .email("henry.wilson@company.com")
                .department("Finance")
                .build()
        );

        participantRepository.saveAll(participants);
        log.info("Created {} sample participants", participants.size());
    }
}   
\end{lstlisting}

\newpage

\begin{appendices}
\section{Mini Project}
\label{app:mini-project}

\subsection{Source Code}

\begin{lstlisting}[caption={HelloApplication.java}, label=lst:hello-app]
package app.hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloApplication {
    public static void main(String[] args) {
        SpringApplication.run(HelloApplication.class, args);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={HelloController.java}, label=lst:hello-controller]
package app.hello.controllers;

import app.hello.services.MessageService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    private final MessageService messageService;

    public HelloController(MessageService messageService) {
        this.messageService = messageService;
    }

    @GetMapping("/hello")
    public String helloWorld() {
        return messageService.getHelloMessage();
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Message.java}, label=lst:message-entity]
package app.hello.entities;

import jakarta.persistence.*;

@Entity
@Table(name = "messages")
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String text;

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    public String getText() { return text; }
    public void setText(String text) { this.text = text; }
}
\end{lstlisting}

\begin{lstlisting}[caption={MessageRepository.java}, label=lst:message-repo]
package app.hello.repositories;

import app.hello.entities.Message;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MessageRepository extends JpaRepository<Message, Integer> {}
\end{lstlisting}

\begin{lstlisting}[caption={MessageService.java}, label=lst:message-service]
package app.hello.services;

import app.hello.entities.Message;
import app.hello.repositories.MessageRepository;
import org.springframework.stereotype.Service;

@Service
public class MessageService {

    private final MessageRepository messageRepository;

    public MessageService(MessageRepository messageRepository) {
        this.messageRepository = messageRepository;
    }

    public String getHelloMessage() {
        System.out.println("MessageService.getHelloMessage() called!");
        return messageRepository.findAll().stream()
                .findFirst()
                .map(Message::getText)
                .orElse("No message found in DB!");
    }
}
\end{lstlisting}
\end{appendices}

\newpage

\section*{References}
\addcontentsline{toc}{section}{References}

\begin{enumerate}
    \item de Moura, L., \& Bjørner, N. (2008). Z3: An efficient SMT solver. \textit{International conference on Tools and Algorithms for the Construction and Analysis of Systems}, 337-340.
    \item Microsoft Research. Z3 Theorem Prover. \url{https://github.com/Z3Prover/z3}
    \item Kroening, D., \& Strichman, O. (2016). \textit{Decision procedures: an algorithmic point of view}. Springer.
    \item Satisfiability Modulo Theories. \url{https://en.wikipedia.org/wiki/Satisfiability_modulo_theories}
    \item Z3 Java API Documentation. \url{https://github.com/Z3Prover/z3/wiki/Java-API}
    \item Spring Framework Documentation. \url{https://spring.io/projects/spring-framework}
    \item JPA Specification. \url{https://jakarta.ee/specifications/persistence/}
    \item Next.js Documentation. \url{https://nextjs.org/docs}
\end{enumerate}

\end{document}